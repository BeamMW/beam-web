[{"_path":"/docs/core-tech/authorization-control-and-signatures-in-contracts","_dir":"core-tech","_draft":false,"_partial":false,"_locale":"","title":"Authorization Control And Signatures In Contracts","description":"In the most common cases the contract method calls Env::AddSig() for each needed public key, and the app shader includes the key material for each key within the SigRequest structure, when it calls Env::GenerateKernel().","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In the most common cases the contract method calls "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Env::AddSig()"}]},{"type":"text","value":" for each needed public key, and the app shader includes the key material for each key within the "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"SigRequest"}]},{"type":"text","value":" structure, when it calls "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Env::GenerateKernel()"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This is a preferred method to design a contract and its application, as it has the following advantages:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Performance: native signature is both compact and fast."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Security: apps have no access to secret keys, they can only derive public keys."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Simplicity."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"However there are more complex situations, where either several users are required to authorize a method call, or a custom signature scheme is required (such as m-out-of-n signature)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Those may include:"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Explicit multisignatures. Several keys are verified (mutliple calls to "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Env::AddSig()"}]},{"type":"text","value":"), belonging to different users."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Seemless multisignatures. There is a single key, but it is a sum (or any linear combination) of several keys, belonging to different users."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Non-standard signature is needed (ring signatures and etc.)."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Any combination of the above"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"On the contract side those are supported. In addition to "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Env::AddSig()"}]},{"type":"text","value":" (which can be invoked arbitrary number of times) the contract has access to "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Secp"}]},{"type":"text","value":" primitives, using which it can implement custom cryptographic scheme verification."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"For apps, however, the default functionality is not enough. Creating a multisigned transaction that is supposed to invoke such a contract assumes that different wallets should cooperate and communicate on behalf of the apps."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"So we extended the BVM functionality to support all the variety of possible signature schemes. Though apps still don't get direct access to secret keys with the added functions, the risk is somewhat greater (more about this later), hence to use those extra functions the app needs an "},{"type":"element","tag":"u","props":{},"children":[{"type":"text","value":"elevated privilege level"}]},{"type":"text","value":" (OFF by default)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Technically those functions are:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Nonce Slots management functions"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"getting an image of a key or a slot, with either standard ("},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"G"}]},{"type":"text","value":") or any custom generator"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"getting a blinded key"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Communication support (via SBBS system)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Env::GenerateKernelAdvanced()"}]},{"type":"text","value":" - with more specific signature control"}]}]},{"type":"element","tag":"h2","props":{"id":"nonce-slots-and-blinded-keys"},"children":[{"type":"text","value":"Nonce slots and blinded keys"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"(the idea of nonce slots is the same as in our HW wallet design)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Generally our supported signatures follow this ritual: first a unique nonce is generated and its image is exposed (in some manner). Then, during the signing, a pseudo-random challenge is derived, and the prover should reveal a linear combination of the secret key and the nonce, a.k.a. blinded key."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This scheme is applicable to Schnorr's signature, Ring signature, Groth's 1-out-of-many, and probably many others.\nIt's "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"critically"}]},{"type":"text","value":" important to make sure the nonce is unique, i.e. not reused for the same secret key in different signatures."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"So we decided to add appropriate support functions for the apps: generate unique nonces, get their images, and get blinded keys:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Generate unique nonce.\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"BVM generates a nonce using system random and state mutation."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"optionally app can specify extra seed data to strengthen the nonce (i.e. less dependency on system random)."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Get nonce image (arbitrary number of times, with arbitrary generators)."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Get blinded key.\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"The app supplies the needed key material (a.k.a. "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"KeyID"}]},{"type":"text","value":", "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"SigRequest"}]},{"type":"text","value":"), arbitrary challenge (scalar) and the nonce slot number."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Once the nonce is used - it's immediately wiped."}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"By such apps are given opportunity to build complex signature schemes, without either direct access to the secret keys, or the feasible opportunity to extract them."}]},{"type":"element","tag":"h1","props":{"id":"building-a-custom-signature-scheme"},"children":[{"type":"text","value":"Building a custom signature scheme"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"As we mentioned, an app can create a custom signature (such as Ring signature), include it in the contract method invocation arguments, then the contract shader may verify it by implementing the needed verification scheme (in terms of "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Secp"}]},{"type":"text","value":" primitives)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Apps can generate such signatures by the provided functionality: obtaining nonce images, and getting blinded keys for the needed challenges."}]},{"type":"element","tag":"h3","props":{"id":"risk-of-signature-hijacking"},"children":[{"type":"text","value":"Risk of signature "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"hijacking"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"When using native signature ("},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"SigRequest"}]},{"type":"text","value":"/"},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"AddSig()"}]},{"type":"text","value":"), it's included in the kernel multi-signature, which also includes its blinding factor. Other users can't take it as-is and use in their transactions (it's not feasible to build a transaction with unknown blinding factor)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In contrast, the custom signature is not automatically bound to the kernel blinding factor. Hence any other user that monitors transactions can build its own transaction that invokes the same method with exactly the same arguments."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"To mitigate this threat we recommend the following scheme:"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Normally challenges for signatures are derived using "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Random Oracle Model"}]},{"type":"text","value":", which is initialized with the message being-signed, this binds the signature for this specific message."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"So we recommend deriving an arbitrary ephemeral (unique) key. Its image (pubKey) should be included in the method arguments, and initialize the "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Oracle"}]},{"type":"text","value":" (challenges derivation), "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"AND"}]},{"type":"text","value":" it also should be included in the "},{"type":"element","tag":"u","props":{},"children":[{"type":"text","value":"native"}]},{"type":"text","value":" kernel signature (i.e. "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Env::AddSig()"}]},{"type":"text","value":")."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"So we recommend using a hybrid of a custom and native signatures. Instead of binding the signature to a message, we recommend binding it to an ephemeral key, whose signature in turn is bound to the kernel blidning factor. By such it's no more feasible to hijack the signature."}]},{"type":"element","tag":"h1","props":{"id":"building-a-mutli-signed-transaction-using-native-signature"},"children":[{"type":"text","value":"Building a mutli-signed transaction using native signature"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In simple scenario the app calls "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Env::GenerateKernel()"}]},{"type":"text","value":", and supplies the info about how it should be signed (gives array of "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"SigRequest"}]},{"type":"text","value":"), the signing itself is deferred until a later stage. Hence some kernel parameters may still vary: min/max height, fee."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"For multi-signed transactions this is different. All the kernel parameters must be decided in advance, so that all the challenges can be derived.\nThose include:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Standard parameters: "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"contractID"}]},{"type":"text","value":", method number, args"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"min/max heights"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"kernel fee"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Funds balance"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Kernel blinding factor image\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"together with Funds balance is used to derive kernel "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Commitment"}]}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Total nonce image, which includes\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"internal BVM nonce for the kernel blinding factor"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"all the nonces the app uses for the keys used in the signature"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"all the nonces the apps running in different wallets use for their keys"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"From all this the challenges are derived."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Then it's the apps's task to calculate the signature: the sum of all the needed blinded keys (its own, as well as of other users)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Technically the flow goes like this:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Decide auxiliary kernel parameters (heights, fee)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"get nonce images"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"get the image of additional nonce, which would be used by the BVM to blind the kernel blinding factor"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"for all the co-signers:\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"co-signers send their (cumulative) nonces for their keys"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"sum all the nonces"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Call Env::GenerateKernelAdvanced() for the 1st time to derive the challenges"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Extract the blinded keys, using the appropriate nonces and derived challenges"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"for all the co-signers:\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Signer sends them the total nonce and the kernel blidning factor, so that they cal also derive the challenges"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"co-Signers reply with the sum of their blinded keys"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"sum those blinded keys to get a multi-signature"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Invoke Env::GenerateKernelAdvanced() for the 2nd time, to finally build the transaction."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Some examples of this flow:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"vault"}]},{"type":"text","value":" app: example of a seamless multisignature, where a vault "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"PubKey"}]},{"type":"text","value":" is actually a sum of the keys of 2 users. The contract code is unmodified (i.e. doesn't care if this is a multi-owned account)."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"upgradable2"}]},{"type":"text","value":" contract and app: example of an explicit multisignature, where the contract demands authorization by multiple keys."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"more examples to come, to demonstrate custom signature schemes"}]}]},{"type":"element","tag":"h1","props":{"id":"security-considerations"},"children":[{"type":"text","value":"Security considerations"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"When app is invoked in the wallet, it's possible to define its "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"privilege level"}]},{"type":"text","value":", which may restrict its access to potentially dangerous functionality."}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Level 0: apps have no access to any user-specific info, and no permission to create transactions. They can only interpret and display the blockchain status information. This is considered safe (though of course the info that app displays may be misleading)."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Level 1 (default): Apps have an access to user's public keys (only those related to contracts), and can ask to create transactions. For the transactions the user sees the resulting balance (funds in/out), and they need user approval. There are 2 risks to consider:"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"There is no reliable way to know it the funds are spent as supposed. A malicious app can steal those funds by sending them such that they won't be accessible by the user in the future."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"App may try to deanonymize the user. It may derive multiple public keys, which are normally intended for different contracts, and expose them in some transaction in a seamless way (a disguised parameter to some contract, recognized by the attacker)."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Level 2: Apps have access to blinded keys."},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"A malicious app can sign "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"arbitrary"}]},{"type":"text","value":" transaction to steal the user funds."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Although such a risk already exists at privilege level 1, here it's somewhat greater, because the leaked signature may be used later, not necessarily during the app invocation."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Level 3: Apps have access to inter-wallet communication."},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"This somewhat increases the risk of disguised signature leakage: Rather than hiding the leaked signature for the attacker on-chain in the explicit tx, a malicious app can now communicate it directly to the attacker."}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"conclusion"},"children":[{"type":"text","value":"Conclusion"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"At any privilege level above 0 there is a risk of deanonymization and funds theft. So we strongly suggest using only trusted apps: either reviewed and built by the user, or signed by trusted 3rd-party developers."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Anyway the deanonymization and theft risks are bounded by the contracts. Apps have no access to other wallet keys (UTXOs, shielded outputs, onwer key, and etc."}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"nonce-slots-and-blinded-keys","depth":2,"text":"Nonce slots and blinded keys","children":[{"id":"risk-of-signature-hijacking","depth":3,"text":"Risk of signature hijacking"}]},{"id":"conclusion","depth":2,"text":"Conclusion"}]}},"_type":"markdown","_id":"content:docs:core-tech:Authorization-control-and-signatures-in-contracts.md","_source":"content","_file":"docs/core-tech/Authorization-control-and-signatures-in-contracts.md","_extension":"md"}]