[{"_path":"/docs/core-tech/transaction-ordering-and-front-running-protection","_dir":"core-tech","_draft":false,"_partial":false,"_locale":"","title":"Transaction Ordering And Front Running Protection","description":"The following is a design of a trading system, which aims to achieve 2 goals:","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The following is a design of a trading system, which aims to achieve 2 goals:"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Front-running protection."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Provide faster confirmation time."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"It consists of 2 parts that should be implemented:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Layer-1 (contract)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Layer-2 (node/miner, transaction creation)"}]}]},{"type":"element","tag":"h2","props":{"id":"layer-1"},"children":[{"type":"text","value":"Layer-1"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The idea is to enforce strict transaction ordering. The transaction that relies on specific states of the contracts invoked, should only be included at the intended position. Should not be possible to include if other transaction that may have relevant effects is included in front of it."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This is achieved by a special synchronization contract, named "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Semaphore"}]},{"type":"text","value":", designed to be invoked by other contracts. Its state consists of a single hash value, which effectively denotes the current state of the trading system. When a contract that operates in such a synchronized manner is invoked - it in turn invokes the "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Semaphore"}]},{"type":"text","value":" contract, which does the following:"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Verifies that its current state is indeed what it should be."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Mutates its state w.r.t. the caller contract, and the details (parameters) of its invocation."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"That is, a pseudo code of the "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Semaphore"}]},{"type":"text","value":" looks like this:"}]},{"type":"element","tag":"pre","props":{"className":["language-C++"],"code":"OnSynchronize(Hash initialValue, int iMethod, Blob params)\n{\n    Hash currentValue = LoadState();\n    if (currentValue != initialValue)\n        Halt(); // order violation!\n\n    HashCalculator calc;\n    calc\n        << initialValue\n        << get_CallerContractID()\n        << iMethod\n        << params;\n\n    calc >> currentValue;\n    SaveState(currentValue);\n}\n","language":"C++","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"OnSynchronize(Hash initialValue, int iMethod, Blob params)\n{\n    Hash currentValue = LoadState();\n    if (currentValue != initialValue)\n        Halt(); // order violation!\n\n    HashCalculator calc;\n    calc\n        << initialValue\n        << get_CallerContractID()\n        << iMethod\n        << params;\n\n    calc >> currentValue;\n    SaveState(currentValue);\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Then, any other contract that enforces ordering:"}]},{"type":"element","tag":"pre","props":{"className":["language-C++"],"code":"OnSomeMethod(Hash semaphoreState, Blob params)\n{\n      // ... ensure correct access order\n      CallFar(semaphoreContractID, semaphoreState, methodID, params);\n      // ... continue as usual\n}\n","language":"C++","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"OnSomeMethod(Hash semaphoreState, Blob params)\n{\n      // ... ensure correct access order\n      CallFar(semaphoreContractID, semaphoreState, methodID, params);\n      // ... continue as usual\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"By such strict transaction order is enforced, and any transaction, if accepted, yields exactly the results anticipated by the user."}]},{"type":"element","tag":"h2","props":{"id":"layer-2"},"children":[{"type":"text","value":"Layer 2"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The above solves the front-running problem, but if implemented alone means that only a single "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Semaphore"}]},{"type":"text","value":"-dependent transaction can be mined in a block.\nThe next step is improving the management of the transaction pool. That is pending transactions, that are supposed to be mined at some point, but not mined yet. It consists of the following:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Node should report all the pending transactions in the pool (already implemented)."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Node should support the blockchain state querying (contract variables and etc.), which includes the side effects of the selected transactions.\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"This is needed to create a transaction that is supposed to be included after a specific pending transaction."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"When transaction is broadcast, it may specify after which other transaction it should be included.\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Then its validation should be done on top of that other transaction respectively."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"For mining, more sophisticated transaction selection algorithm should be used\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"At the moment, transaction set is considered "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"flat"}]},{"type":"text","value":", the node selects them according to their fee/resources ratio."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"A more correct algorithm should organize transactions in a set of "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"trees"}]},{"type":"text","value":" of dependent transactions."}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Once implemented, this achieves the following:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Many transactions may be included in the block, yet their order is guaranteed."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Public fee market. In case of order conflict, i.e. different users send transactions for the same order, they are encouraged to pay more fees to be selected."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Faster effective confirmation times. Although the average block time remains the same, the transactions are already visible in the pool. The more transactions (and their fees) are placed on top of a user transaction - the more likely it will be included in that order. Users may even send additional dependent transactions on top of their previous ones, before they are finally confirmed in a block."}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"layer-1","depth":2,"text":"Layer-1"},{"id":"layer-2","depth":2,"text":"Layer 2"}]}},"_type":"markdown","_id":"content:docs:core-tech:Transaction-ordering-and-front-running-protection.md","_source":"content","_file":"docs/core-tech/Transaction-ordering-and-front-running-protection.md","_extension":"md"}]