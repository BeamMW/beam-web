[{"_path":"/docs/core-tech/cryptographic-primitives","_dir":"core-tech","_draft":false,"_partial":false,"_locale":"","title":"Cryptographic Primitives","description":"Cryptographic primitives used by BEAM are based on the secp256k1 library (the one that is used in bitcoin). Naturally it uses the same elliptic curve equation. The following primitives are used directly:","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Cryptographic primitives used by BEAM are based on the "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"secp256k1"}]},{"type":"text","value":" library (the one that is used in bitcoin). Naturally it uses the same elliptic curve equation. The following primitives are used directly:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"secp256k1_gej"}]},{"type":"text","value":" - Basic curve point arithmetics: point addition, doubling, negation, import/export to a platform-ndependent format."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"secp256k1_scalar"}]},{"type":"text","value":" - Scalar arithmetics: addition, multiplication, inverse"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"secp256k1_sha256_t"}]},{"type":"text","value":" - SHA-256 hash"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Cryptographic nonce generation ("},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"nonce_function_rfc6979"}]},{"type":"text","value":")."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"secp256k1_hmac_sha256_t"}]},{"type":"text","value":" - HMAC (message authentication)"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The following cryptographic functions and schemes are built over them:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Point multiplication (by a scalar).\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"There are different multiplication modes and scenarios:\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Secure/Fast"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Point may be either known in advance (a.k.a. Generator, prepared for multiplication) or \"casual\"."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Aggregation: when many points are multiplied by scalars and summed - an appropriate effective algorithm is used."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"The reason that this functionality is implemented in BEAM and not taken directly from "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"secp256k1"}]},{"type":"text","value":" is the following:\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"We'd like to have more low-level control of the primitives to implement advanced schemes"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"We need more generators: Standard secp256k1 supports just two ("},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"G,H"}]},{"type":"text","value":"), whereas we need many more (131)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"No effective aggregation implementation"}]}]}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Commitments (encoded amount with the blinding factor)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Schnorr's signatures (including multi-sig)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Bulletproofs (including multi-sig and batch verification)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Secure communication channels"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Secure BBS messaging system"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In addition there's a "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"uintBig"}]},{"type":"text","value":" - a \"big integer\" (arbitrary width), supports basic arithmetics and shift operations (not including division). The number is represented as an array of bytes in a big-endian byte order. Platform-independent, serialized as-is.\nImplementation is very straight-forward, not for performance-critical tasks."}]},{"type":"element","tag":"h2","props":{"id":"hash"},"children":[{"type":"text","value":"Hash"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The Hash refers to the SHA-256 hash, unless otherwise specified. Used in various schemes. When hashing some data, it's fed in a way that is both platform-independent and unambiguous. This is achieved by the following specifications:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"1-byte data is fed as-is"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Boolean values are encoded as a single byte with value either 0 or 1."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Strings are fed as-is, "},{"type":"element","tag":"u","props":{},"children":[{"type":"text","value":"including"}]},{"type":"text","value":" the 0-terminator (to prevent ambiguity for consequent strings)."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Numerical types (fixed-point) are stored as a variable-length byte sequence, with a special terminator mark. This ensures platform independence (integers may have varying width across different platforms)."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Non-primitive types are converted into the platform-independent binary format for hashing."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The following objects are derived from hash (built over them)"}]},{"type":"element","tag":"h3","props":{"id":"oracle"},"children":[{"type":"text","value":"Oracle"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Oracle is used in non-interactive cryptographic proofs, it's supposed to produce cryptographic challenges in a deterministic way, based on the visible transcript to the moment."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In BEAM Oracle uses the Hash in a straightforward way. All the visible transcript is hashed. Once the challenge is needed - the hash value is finalized, the result is the challenge, and it's immediately re-fed to the Hash. So that the new challenge construction (if needed) is generated from the visible transcript, "},{"type":"element","tag":"u","props":{},"children":[{"type":"text","value":"including"}]},{"type":"text","value":" the previous challenge."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"If there are restrictions for the challenge (such as it should be non-overflowing, non-zero scalar, or a valid x-coordinate of a curve point) - the Finalize-Re-feed is called in a loop, until the satisfying challenge is produced (i.e. accept/reject strategy is used)."}]},{"type":"element","tag":"h3","props":{"id":"nonce-generator"},"children":[{"type":"text","value":"Nonce Generator"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Also used in cryptographic proofs, but, unlike Oracle, the nonce generation involves secret data, and should not be possible to reconstruct by others."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In BEAM Nonce generator is a combination of an Oracle, and the nonce function initialized by the secret data. That is, the Oracle accounts for all the visible transcript. When a nonce is needed - first it's received from the Oracle, and then passed as an input to the nonce function (implemented in ("},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"secp256k1"}]},{"type":"text","value":"), which also uses the secret data."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The final nonce generation function implemented in "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"secp256k1"}]},{"type":"text","value":" actually a modified HMAC-SHA-256 scheme."}]},{"type":"element","tag":"h3","props":{"id":"kdf-key-derivation-function"},"children":[{"type":"text","value":"KDF - Key derivation function"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"All the private keys are generated via KDF. In BEAM it's implemented via the Nonce generator, which is initialized once by the master secret data. The requested key parameters (key index, type/subtype, etc.) are hashed and then the output is generated by the standard Nonce generator initialized with the master secret."}]},{"type":"element","tag":"h2","props":{"id":"schnorrs-signature"},"children":[{"type":"text","value":"Schnorr's signature"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Implemented according to the standard, the \"long\" version, compatible with batch verification. Consists of a pair "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"[P,k]"}]},{"type":"text","value":", whereas "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"P"}]},{"type":"text","value":" is an arbitrary EC point, and "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"k"}]},{"type":"text","value":" is the blinded private key. Supports multisignature of course."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Specifically the scheme is the following. Given a message hash "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"M"}]},{"type":"text","value":", private key "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"sk"}]},{"type":"text","value":", public key "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"pk = G * sk"}]},{"type":"text","value":":"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Prover\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Generate a nonce "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"nk = Nonce(sk, M)"}]},{"type":"text","value":", whereas "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Nonce()"}]},{"type":"text","value":" is the standard nonce generating function."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Calculate: "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"P = nk*G"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Expose to Oracle: "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"P, M"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Get the challenge "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"e"}]},{"type":"text","value":" from Oracle."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Calculate "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"k = - nk - e*sk"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Signature: "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"[P, k]"}]}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Verifier\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Expose to Oracle: "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"P, M"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Get the challenge "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"e"}]},{"type":"text","value":" from Oracle."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Verify: "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"k*G + e*Pk + P == 0"}]}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"binary-platform-independent-representation-of-the-ecc-primitives"},"children":[{"type":"text","value":"Binary platform-independent representation of the ECC primitives"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The following are the primitives:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ECC Scalar\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"256-bits wide integer, representing the number in a big-endian format (via "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"uintBig"}]},{"type":"text","value":")"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Deserialization ensures the number is indeed a valid scalar, i.e. strictly less than modulo-prime, to prevent ambiguity"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ECC Point\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Represented as an X-coordinate, and a Y-parity flag (1 bit)."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"The X-coordinate is serialized via "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"uintBig"}]},{"type":"text","value":" (similar to scalar)."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"To recover the Y-coordinate one must solve a quadratic equation, which, naturally has 2 solutions. This is where Y-parity flag is used."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"When serialized individually the data is padded to a byte boundary (means the Y-parity bit takes the whole byte). However in some complex data types those flags are merged and stored separately (Ex: Bulletproofs)."}]}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"hash","depth":2,"text":"Hash","children":[{"id":"oracle","depth":3,"text":"Oracle"},{"id":"nonce-generator","depth":3,"text":"Nonce Generator"},{"id":"kdf-key-derivation-function","depth":3,"text":"KDF - Key derivation function"}]},{"id":"schnorrs-signature","depth":2,"text":"Schnorr's signature"},{"id":"binary-platform-independent-representation-of-the-ecc-primitives","depth":2,"text":"Binary platform-independent representation of the ECC primitives"}]}},"_type":"markdown","_id":"content:docs:core-tech:Cryptographic-primitives.md","_source":"content","_file":"docs/core-tech/Cryptographic-primitives.md","_extension":"md"}]