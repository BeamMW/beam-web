{"_path":"/docs/core-tech/hw-wallet-requirements-deprecated","_dir":"core-tech","_draft":false,"_partial":false,"_locale":"","title":"-- DEPRECATED --","description":"The HW wallet should support the following functionality","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"deprecated"},"children":[{"type":"text","value":"-- DEPRECATED --"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The HW wallet should support the following functionality"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Deterministic key generation for key parameters"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Export public keys"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Participate in signing schemes: Schnorr's signature, Bulletproof.\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"The latter in CPU-hungry, but most of the computations can be done without HW"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Support multi-signatures\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"This includes both: signing with multiple self keys, as well as the keys generated by the others."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Obviously secret keys must not be revealed."}]}]},{"type":"element","tag":"h2","props":{"id":"nonces-and-randomness"},"children":[{"type":"text","value":"Nonces and randomness"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Our signing protocols follow a ritual where the signer generates some "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"nonce(s)"}]},{"type":"text","value":", reveals its "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"image(s)"}]},{"type":"text","value":", gets a "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"challenge(s)"}]},{"type":"text","value":", and then should reveal the appropriate "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"preimage"}]},{"type":"text","value":". To guarantee (5) the signer must "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"never"}]},{"type":"text","value":" answer to different "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"challenges"}]},{"type":"text","value":" for the same "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"nonce"}]},{"type":"text","value":". This is absolutely vital!"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In a regular signature protocol the "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"nonce"}]},{"type":"text","value":" can always be generated in a deterministic way from the visible transcript and the sercret key, the "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"challenge"}]},{"type":"text","value":" is derived from the visible transcript, and the whole signing process is "},{"type":"element","tag":"u","props":{},"children":[{"type":"text","value":"atomic"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This approach, however, is not compatible with (4). In the case of the multisignature the signing process is not atomic. And ability to create multisignatures is essential in MW."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Hence, in order to sustain the requirements the HW should use another source of (pseudo)randomness. Moreover, the random "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"nonce"}]},{"type":"text","value":" generated for the signing process should be kept inside the HW for indefinite time, because signing may take considerable time, during which HW wallet should be able to operate normally. In addition each "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"nonce"}]},{"type":"text","value":" should be "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"erased"}]},{"type":"text","value":" once the "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"preimage"}]},{"type":"text","value":" based on it is revealed."}]},{"type":"element","tag":"h1","props":{"id":"proposed-design"},"children":[{"type":"text","value":"Proposed design"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"HW wallet should support the basic EC cryptography primitives for the parameters specified by the "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"secp256k1"}]},{"type":"text","value":" standard (the one that is used in bitcoin). Means - 256-bit wide keys, the same EC equation, finite field parameters, same "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"G"}]},{"type":"text","value":"-generator."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The HW wallet should have non-volatile memory, represented by memory "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"slots"}]},{"type":"text","value":". There should be the following "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"slots"}]},{"type":"text","value":":"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Master secret.\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"No direct access to the caller."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Should be used as a secret for key generation."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Nonce source.\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"No direct access to the caller."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Should be initialized by "},{"type":"element","tag":"u","props":{},"children":[{"type":"text","value":"true random"}]},{"type":"text","value":" either during production, or upon initialization of the Master secret."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Generated key.\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Contains the generated key. May be a single key or their sum/difference (more about this later)."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Generated nonces."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This low-level design may look weird, but it's needed to support all the MW functionality. The following functionality should be supported:"}]},{"type":"element","tag":"h3","props":{"id":"nonce-regeneration"},"children":[{"type":"text","value":"Nonce regeneration"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Parameters:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"i"}]},{"type":"text","value":" - the target slot index"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Result: the target slot should contain a unique nonce, derived from the Nonce source, and the Nonce source itself should be mutated immediately after that."}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"n[i] = DeriveNonce(NonceSource)"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"NonceSource = Mutate(NonceSource)"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"u","props":{},"children":[{"type":"text","value":"Important"}]},{"type":"text","value":": all the nonce slots must be regenerated before (or immediately after) the Master secret is initialized. In simple words, there must be no situation where the HW is operational, yet there's a nonce slot which contains predictable (zero?) value."}]},{"type":"element","tag":"h3","props":{"id":"key-slot-reset-assign-to-zero"},"children":[{"type":"text","value":"Key slot reset (assign to zero)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Result: the target slot should contain zero value: "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"k = 0"}]}]},{"type":"element","tag":"h3","props":{"id":"key-generation"},"children":[{"type":"text","value":"Key generation"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Parameters:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"ID"}]},{"type":"text","value":" - an opaque 256-bit data that identifies the key"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Result: the generated key should be "},{"type":"element","tag":"u","props":{},"children":[{"type":"text","value":"added"}]},{"type":"text","value":" to the target slot: "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"k += KeyGenerate(MasterSecret, ID)"}]}]},{"type":"element","tag":"h3","props":{"id":"key-split"},"children":[{"type":"text","value":"Key split"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The key should be split into 2 parts in a deterministic (yet opaque) way."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Return value: "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"k2 = Muate(k)"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Result: "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"k -= k2"}]}]},{"type":"element","tag":"h3","props":{"id":"image-public-key-reveal"},"children":[{"type":"text","value":"Image (public key) reveal"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Parameters:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"i"}]},{"type":"text","value":" - the slot index."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Return value: EC point (in whatever representation) equals to the "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"G"}]},{"type":"text","value":"-generator multiplied by the value of this slot: "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"G * n[i]"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Applicable for key and nonce slots"}]},{"type":"element","tag":"h3","props":{"id":"sig1-schnorr"},"children":[{"type":"text","value":"Sig1 (Schnorr)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Parameters:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"i"}]},{"type":"text","value":" - the slot index"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"e"}]},{"type":"text","value":" - challenge"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Return value: blinded "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"preimage"}]},{"type":"text","value":": "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"kb = n[i] + e*k"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Result: used nonce is immediately regenerated: "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Regenerate(i)"}]}]},{"type":"element","tag":"h3","props":{"id":"sig2-bulletproof"},"children":[{"type":"text","value":"Sig2 (Bulletproof)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Parameters:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"i1, i2"}]},{"type":"text","value":" - 2 slot indexes"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"e"}]},{"type":"text","value":", "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"e2"}]},{"type":"text","value":" - 2 challenges"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Return value: blinded "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"preimage"}]},{"type":"text","value":": "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"kb = n[i1] + e2*n[i2] + e*k"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Result: used nonce is immediately regenerated: "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Regenerate(i1)"}]},{"type":"text","value":", "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Regenerate(i2)"}]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"h1","props":{"id":"api"},"children":[{"type":"text","value":"API"}]},{"type":"element","tag":"h3","props":{"id":"key-generation-1"},"children":[{"type":"text","value":"Key generation"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Inputs:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"KIDV"}]},{"type":"text","value":" for the needed key\nOtputs:"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"The public key (ECC point)"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Generate the key, and export its image (i.e. multiplies by "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"G"}]},{"type":"text","value":"-generator)"}]},{"type":"element","tag":"h3","props":{"id":"bulletproof-generation"},"children":[{"type":"text","value":"Bulletproof generation"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Inputs:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"KIDV"}]},{"type":"text","value":" for the needed key\nOtputs:"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"The Bulletproof"}]}]},{"type":"element","tag":"h3","props":{"id":"nonce-generation"},"children":[{"type":"text","value":"Nonce generation"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Inputs:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Slot number\nOtputs:"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"The nonce image (ECC point)"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Generate the random nonce (ECC scalar), and export its image (i.e. multiplies by "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"G"}]},{"type":"text","value":"-generator)."}]},{"type":"element","tag":"h3","props":{"id":"transaction-signature"},"children":[{"type":"text","value":"Transaction signature"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Inputs:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"List of "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"KIDV"}]},{"type":"text","value":"s of input UTXOs"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"List of "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"KIDV"}]},{"type":"text","value":"s of output UTXOs"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Randomly generated offset (ECC scalar)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Number of the nonce slot"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Challenge "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"e"}]},{"type":"text","value":" (ECC scalar) // after discussion, it seems that it should be calculated on device, so we need kernel parameters\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Fee"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Commitment // total public excess"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"minimal height"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"maximum height"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Amount(m_AssetEmission)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"m_pHashLock;"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Public nonce of 2nd party (for multisig)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Public excess of 2nd party (for multisig)"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Outputs:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Signature (ECC scalar)"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The HW wallet should do the following:"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Request user's permission for the transaction."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Calculate the result."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Immediately overwrite the nonce slot with another randomly-generated value."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The result is calculated by the following algorithm:"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Generate all the keys (i.e. blinding factors), and calculate "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"sk"}]},{"type":"text","value":" as sum of inputs minus outputs."},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"sk = Sum(input blinding factors) - Sum(output blinding factors) - offset"}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"offset"}]},{"type":"text","value":" is generated randomly on caller side"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Calculate multi signature public nonce: "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"PublicNonce = Nonce*G + PeerPublicNonce"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Calculate total blinding excess: "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"TotalExcess = sk * G + PeerPublicExcess"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Calculate Message for sign: hash kernel parameters see: TxKernel::get_Hash"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Calculate challenge by: "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"e = H(PublicNonce|Message)"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Calculate the signature by: "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Signature = sk * e + Nonce"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Re-generate "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Nonce"}]},{"type":"text","value":" (overwrite the contents of the slot)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Reveal "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Signature"}]}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"nonces-and-randomness","depth":2,"text":"Nonces and randomness","children":[{"id":"nonce-regeneration","depth":3,"text":"Nonce regeneration"},{"id":"key-slot-reset-assign-to-zero","depth":3,"text":"Key slot reset (assign to zero)"},{"id":"key-generation","depth":3,"text":"Key generation"},{"id":"key-split","depth":3,"text":"Key split"},{"id":"image-public-key-reveal","depth":3,"text":"Image (public key) reveal"},{"id":"sig1-schnorr","depth":3,"text":"Sig1 (Schnorr)"},{"id":"sig2-bulletproof","depth":3,"text":"Sig2 (Bulletproof)"},{"id":"key-generation-1","depth":3,"text":"Key generation"},{"id":"bulletproof-generation","depth":3,"text":"Bulletproof generation"},{"id":"nonce-generation","depth":3,"text":"Nonce generation"},{"id":"transaction-signature","depth":3,"text":"Transaction signature"}]}]}},"_type":"markdown","_id":"content:docs:core-tech:HW-wallet-requirements----DEPRECATED---.md","_source":"content","_file":"docs/core-tech/HW-wallet-requirements----DEPRECATED---.md","_extension":"md"}