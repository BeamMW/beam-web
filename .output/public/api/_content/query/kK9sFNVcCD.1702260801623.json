[{"_path":"/docs/core-tech/ethash-verification-in-contracts","_dir":"core-tech","_draft":false,"_partial":false,"_locale":"","title":"Ethash Verification In Contracts","description":"To implement trustless bridges between Beam and other blockchains there's a need to verify the headers of the appropriate blockchains in the contract. For a PoW-based blockchain there's a need to verify the appropriate header PoW.","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"To implement trustless bridges between Beam and other blockchains there's a need to verify the headers of the appropriate blockchains in the contract. For a PoW-based blockchain there's a need to verify the appropriate header PoW."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Ethereum mined according to Ethash PoW algorithm. Turns out not only mining, but even the verification of Ethash is a complex task for a contract."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"UPDATE: (2021-05-09)"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Turns out a very similar idea has already been elaborated by "},{"type":"element","tag":"a","props":{"href":"https://blog.kyber.network/waterloo-a-decentralized-practical-bridge-between-eos-and-ethereum-c25b1698f010","rel":["nofollow"]},"children":[{"type":"text","value":"Kyber"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"And threre's a "},{"type":"element","tag":"a","props":{"href":"https://near.org/technology/","rel":["nofollow"]},"children":[{"type":"text","value":"Rainbow Ethereum-NEAR Rainbow Bridge"}]},{"type":"text","value":" deployed using this technology."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"While the idea is very similar, there are significant differences in the implementation. Our version is somewhat more efficient (in both proof size and verification times) since we use a more sophisticated variation of the Merkle proofs."}]},{"type":"element","tag":"h1","props":{"id":"ethash"},"children":[{"type":"text","value":"Ethash"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Ethash is designed to be memory-hard. Its hi-level design:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Mining parameters (a.k.a. "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Epoch"}]},{"type":"text","value":") are changed each 30K blocks (roughly 5.2 days)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"For the current "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Epoch"}]},{"type":"text","value":" a "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Cache"}]},{"type":"text","value":" is generated, which as a pseudo-random opaque data set.\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Its size is gradually increased with each "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Epoch"}]},{"type":"text","value":", as of today its size is roughly "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"70MB"}]},{"type":"text","value":"."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"The cache generation is deliberately complex. Each element depends on the previous (so that it can't be parallelized), and CPU-intensive hash function is used."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"As for today it takes "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"several seconds"}]},{"type":"text","value":" to calculate on a typical desktop machine."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"There is a much larger data set that can be calculated from the cache (a.k.a. "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"DAG"}]},{"type":"text","value":").\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"As for today the cache size is roughly "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"4GB"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Each element calculation is deliberately complex. Involves CPU-intensive hash functions, and pseudo-random access of cache."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Elements however are independent"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The PoW puzzle is to find a "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"nonce"}]},{"type":"text","value":", from which a 64-element-long pseudo-random "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Path"}]},{"type":"text","value":" is derived, whose last element together with the "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"nonce"}]},{"type":"text","value":" reaches the difficulty target. It is assumed that effective miner should have the "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"DAG"}]},{"type":"text","value":" in memory, and probe different pseudo-random paths until the needed difficulty target is reached. To verify the PoW only the cache is needed. The chosen path elements can effectively be calculated from the cache (since they are independent)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"So that, unlike most of the other blockchains, Ethash verification demands significant memory. Once the cache is prepared, the PoW verification is reasonably fast, but still may be considerable if many headers should be verified at once."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"For native Ethereum clients this is not a problem. Normally they interpret blocks/headers sequentially (perhaps with slight reorgs), so that the cache can be generated once and kept in memory for ~5 days. The complexity of verification of a header (tens of milliseconds) is also acceptable."}]},{"type":"element","tag":"h1","props":{"id":"why-ethash-verification-is-hard-in-contract"},"children":[{"type":"text","value":"Why Ethash verification is hard in contract"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"First of, the cache is needed. As we mentioned it has size roughly "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"70MB"}]},{"type":"text","value":" (as for today), and computation time of several seconds, even if done natively. This is totally unrealistic for contracts, which are deliberately restricted in both available memory and running time."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"One strategy to solve this problem (that we tried) is to provide contracts a special bvm function. It would be like this:"}]},{"type":"element","tag":"pre","props":{"className":["language-C++"],"code":"hash256 get_EthashDagEndpoint(int epochNumber, hash512 seed);\n","language":"C++","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"hash256 get_EthashDagEndpoint(int epochNumber, hash512 seed);\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The bvm implementation would generate and keep the cache for the specified Epoch in memory, and interpret the needed path for the contract. The rest of the header verification (seed derivation, difficulty test, etc.) can be done inside the contract."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This strategy however has the following drawbacks:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Adding very specialized functions to the bvm is a drawback. We prefer to keep the functions very generic, and avoid specialized functions unless there's no other option."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Unlike native Ethereum clients, it's not possible to assume that only the current Epoch would be needed. Contracts might need to process headers from the past, as well as headers from different sidechains with different heights."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Calculating the cache for each requested Epoch is heavy. Pre-calculating and keeping many of them in the local storage is unrealistic too for most of the clients, because of the considerable cache size of each Epoch."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Since the contract may want to process many Ethereum headers at once, the performance may be complex even with prepared cache."}]}]},{"type":"element","tag":"h1","props":{"id":"our-strategy"},"children":[{"type":"text","value":"Our strategy"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"First let's study the pseudo-code of the supposed "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"get_EthashDagEndpoint"}]},{"type":"text","value":":"}]},{"type":"element","tag":"pre","props":{"className":["language-C++"],"code":"hash256 get_EthashDagEndpoint(int epochNumber, hash512 seed)\n{\n    Init MyState from seed;\n    loop 64 times:\n    {\n        derive Index from MyState;\n        get hash1024 Element from DAG of the specified epoch at position Index;\n        mutate MyState by Element\n    }\n\n    derive Hash256 MixHash from MyState;\n    return  MixHash;\n}\n","language":"C++","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"hash256 get_EthashDagEndpoint(int epochNumber, hash512 seed)\n{\n    Init MyState from seed;\n    loop 64 times:\n    {\n        derive Index from MyState;\n        get hash1024 Element from DAG of the specified epoch at position Index;\n        mutate MyState by Element\n    }\n\n    derive Hash256 MixHash from MyState;\n    return  MixHash;\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Note that this code can basically be implemented in the contract. The "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"MyState"}]},{"type":"text","value":" mutation and consequent "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Index"}]},{"type":"text","value":" derivation are pretty simple (use fast hash function). The problem of course is getting the element from the "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"DAG"}]},{"type":"text","value":" at the requested "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Index"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The idea is to provide those elements for the verification. Means in order to verify the header, in addition to the header itself, the prover would include those 64 1024-bit elements of the path for the contract. Then the contract would repeat the same path and compute the same "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"MixHash"}]},{"type":"text","value":"."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The question is how can the contract verify that the provided elements of the "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"DAG"}]},{"type":"text","value":" are indeed correct. For this the Prover would include the Merkle multi-element proof (more about this later)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"So that the contract gets:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"The header."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"64 elements from the "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"DAG"}]},{"type":"text","value":"."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Merkle proof that proves that the above elements are indeed part of the "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"DAG"}]},{"type":"text","value":", and ("},{"type":"element","tag":"u","props":{},"children":[{"type":"text","value":"importantly!"}]},{"type":"text","value":") they are at the asserted positions."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"So, in order to deploy and use contracts written in this way the following is needed:"}]},{"type":"element","tag":"h3","props":{"id":"setup"},"children":[{"type":"text","value":"Setup."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"For each epoch:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"calculate the "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"DAG"}]},{"type":"text","value":", build a Merkle tree, and save it locally.\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"to reduce the space the lower levels of the tree may be omitted. Each omitted level saves x2 space, and increases x2 the complexity of the consequent proof generations."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Calculate and save the Merkle tree root."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Practically the total number of Epochs can be limited to 1024. This will cover all the headers from the very beginning up to year 2030."}]},{"type":"element","tag":"h3","props":{"id":"deploy-the-contract"},"children":[{"type":"text","value":"Deploy the contract."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"For each Epoch the contract has (hard-coded) the following:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"The size of the "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"DAG"}]},{"type":"text","value":"."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Merkle root."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Alternatively instead of storing this data for each Epoch, we can build yet another Merkle tree. By such the contract would only need a single Merkle root. Then, during the verification, one more Merkle proof would be necessary to verify this specific Epoch params."}]},{"type":"element","tag":"h3","props":{"id":"using"},"children":[{"type":"text","value":"Using"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"To invoke the contract method that is supposed verify the Ethereum header the following is performed by the caller:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Simulate the PoW verification locally. Obtain the 64 Elements that are needed for the path as well as deduce their indexes."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Build the Merkle multi-element proof for those elements, given their indexes."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Concatenate the elements and the Merkle proof, to form a single unified proof."}]}]},{"type":"element","tag":"h2","props":{"id":"merkle-multi-element-proof"},"children":[{"type":"text","value":"Merkle multi-element proof"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The goal is to prove that the specified subset of elements is a part of the original set. A naive way to accomplish this would be providing a separate Merkle proof for each element, which is essentially a set of hashes, by interpreting which the verifier should calculate and verify the Merkle root for each element individually. This is suboptimal however, since hashes are likely to repeat (i.e. show up in proof for different elements). Instead of doing this the prover would provide the minimal set of hashes, by using which the verifier would calculate the Merkle root only once."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In our specific case the verifier knows both the original data set size, and the asserted indexes (positions) of the elements in its subset. We designed our protocol such that it proves not only the existence of those elements in the original set, but also their positions. The simplified verifier pseudo-code would look like this:"}]},{"type":"element","tag":"pre","props":{"className":["language-C++"],"code":"Hash get_Root(Set myElements, int rangeBegin, int rangeSize)\n{\n    if myElements is empty\n        // this is where the prover is supposed to provide the complementary sibling hash\n        return next Hash from the attached proof;\n        \n    if rangeSize == 1\n        // if the myElements contains more than 1 element (i.e. original set of elements contains collisions, unlikely but possible) - make sure they are all equal.\n        return Evaluate hash from myElements[0];\n    \n    // split the range\n    rangeSize /= 2;\n    \n    int pivot = rangeBegin + rangeSize;\n    \n    Split myElements into 2 subsets myElementsLo and myElementsHi, according to pivot;\n    \n    Hash hashLo = get_Root(myElementsLo, rangeBegin, rangeSize);\n    Hash hashHi = get_Root(myElementsHi, pivot, rangeSize);\n    \n    return Hash(hashLo | hashHi);\n}\n","language":"C++","meta":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Hash get_Root(Set myElements, int rangeBegin, int rangeSize)\n{\n    if myElements is empty\n        // this is where the prover is supposed to provide the complementary sibling hash\n        return next Hash from the attached proof;\n        \n    if rangeSize == 1\n        // if the myElements contains more than 1 element (i.e. original set of elements contains collisions, unlikely but possible) - make sure they are all equal.\n        return Evaluate hash from myElements[0];\n    \n    // split the range\n    rangeSize /= 2;\n    \n    int pivot = rangeBegin + rangeSize;\n    \n    Split myElements into 2 subsets myElementsLo and myElementsHi, according to pivot;\n    \n    Hash hashLo = get_Root(myElementsLo, rangeBegin, rangeSize);\n    Hash hashHi = get_Root(myElementsHi, pivot, rangeSize);\n    \n    return Hash(hashLo | hashHi);\n}\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The prover interprets this according to the same logic. It just doesn't evaluate anything, and provides the appropriate Merkle tree hashes when needed."}]},{"type":"element","tag":"h1","props":{"id":"pros-and-cons"},"children":[{"type":"text","value":"Pros and cons"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Pros:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"No need for specialilzed support functions. Hence no additional threat of abuse and etc."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Header verification is reasonably fast."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Cons:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"To invoke the contract the prover needs to generate and process the "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"DAG"}]},{"type":"text","value":"."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"The proof size is considerable.\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"The needed elements take 8K (64 elements, 1024 bits == 128 bytes each)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"The Merkle proof size varies, but seems to be around 1100-1200 hashes for all the elements."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"We decided to use 160-bit hashes, to reduce the proof size, yet have decent security."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"The overall proof size is about "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"30KB"}]}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Overall this solution seems very practical. The proof size, albeit considerable, is not prohibitively large. With our current block size limitation of 1MB it's possible to verify up to tens of Ethereum headers at once.\nThe verification time is reasonably fast too (actually faster than normal verification even with cache prepared). Dominated by the hashing, for which there are native functions provided by the bvm."}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"setup","depth":3,"text":"Setup."},{"id":"deploy-the-contract","depth":3,"text":"Deploy the contract."},{"id":"using","depth":3,"text":"Using"},{"id":"merkle-multi-element-proof","depth":2,"text":"Merkle multi-element proof"}]}},"_type":"markdown","_id":"content:docs:core-tech:Ethash-verification-in-contracts.md","_source":"content","_file":"docs/core-tech/Ethash-verification-in-contracts.md","_extension":"md"}]