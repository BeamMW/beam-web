{"_path":"/docs/core-tech/utxo-set-horizons-and-cut-through","_dir":"core-tech","_draft":false,"_partial":false,"_locale":"","title":"UTXO Set, Horizons And Cut Through","description":"One of the MW benefits is the cut-through, i.e. ability to discard the spent TXOs, yet be able to prove the authenticity of the current state.","body":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"One of the MW benefits is the cut-through, i.e. ability to discard the spent TXOs, yet be able to prove the authenticity of the current state."}]},{"type":"element","tag":"h1","props":{"id":"horizons"},"children":[{"type":"text","value":"Horizons"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The term "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"horizon"}]},{"type":"text","value":" in this context denotes a relative distance (in terms of blocks) from the current blockchain tip, subtracting it from the current blockchain height we get the appropriate height that corresponds to this horizon. The blocks and TXOs created/spent below this height are subject to a special processing."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In Beam there are 3 horizons defined:"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Max-rollback distance"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"Fixed, part of the consensus parameters. For mainnet equals to 1440, which corresponds to 1 day for expected block creation rate."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Hi-Horizon"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Lo-Horizon"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The latter 2 horizons can be set to arbitrary values and differ in each node. The following criteria however must be satisfied:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Max-rollback-distance"}]},{"type":"text","value":" <= "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Hi-Horizon"}]},{"type":"text","value":" <= "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Lo-Horizon"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"or in terms of heights:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Max-rollback-Height"}]},{"type":"text","value":" >= "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Hi-Height"}]},{"type":"text","value":" >= "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Lo-Height"}]}]}]},{"type":"element","tag":"h2","props":{"id":"max-rollback-distance"},"children":[{"type":"text","value":"Max-rollback distance"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This horizon, as its name suggests, defines the maximum number of the recent blocks accepted by the node as the current consensus branch, that can potentially be reverted in order to switch to a competing branch. Or, speaking simply, this is how deep the reorg can be."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"So that recent blocks are volatile (subject to potential reorgs), but blocks below this height can be considered stable. This defines the minimum number of the recent blocks that each node is obliged to keep (or be able to re-create)."}]},{"type":"element","tag":"h2","props":{"id":"hi-horizon"},"children":[{"type":"text","value":"Hi-Horizon"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Defines how long the spent TXO must be "},{"type":"element","tag":"u","props":{},"children":[{"type":"text","value":"fully"}]},{"type":"text","value":" kept in the node after it was spent."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"For TXOs that are spent below the current "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Hi-Height"}]},{"type":"text","value":" (which is the current blockchain height minus "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Hi-Horizon"}]},{"type":"text","value":") the node will keep the TXO commitment, but not the signature (bulletproof). This is called "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Reduced TXO"}]},{"type":"text","value":" (a.k.a. naked, diluted, skeleton)."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Since the UTXO signature takes most of its size (~95%), getting rid of it has a dramatic impact on the storage size and the amount of information that should be negotiated when such a reduced TXO sent."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Obviously reduced TXO can't be trusted to be a valid TXO object (well-formed, with unknown positive value restricted to 64 bits). However they play an important role in the synchronization process (as we'll see later), and as long as the UTXO set (i.e. unspent TXOs only) doesn't contain reduced TXOs - there is no problem."}]},{"type":"element","tag":"h2","props":{"id":"lo-horizon"},"children":[{"type":"text","value":"Lo-Horizon"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Defines how long the reduced spent TXO must be kept in the node after it was spent. TXOs that are spent below the current "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Lo-Height"}]},{"type":"text","value":" (which is the current blockchain height minus "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Lo-Horizon"}]},{"type":"text","value":") will be completely erased in the node, without any further trace of existence."}]},{"type":"element","tag":"h1","props":{"id":"synchronization"},"children":[{"type":"text","value":"Synchronization"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"During standard synchronization process blocks are downloaded and verified one by one (as in most of the blockchains). However each node can decide to skip several intermediate steps, and \"jump\" to an arbitrary new height. The goal of the cut-through is to support such jumps with minimal amount of information transferred."}]},{"type":"element","tag":"h2","props":{"id":"sparse-blocks"},"children":[{"type":"text","value":"Sparse blocks"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In Beam this is achieved by using "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"sparse blocks"}]},{"type":"text","value":", that contain only parts of the original blocks that are essential to achieve the requested final state. So that during synchronization the node still downloads individual blocks, but they are reduced to the minimum, their verification is delayed until they are all downloaded, and only the final state is fully verified."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"When requesting the sparse block the following information must be specified:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Block identifier ("},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Height"}]},{"type":"text","value":", "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Hash"}]},{"type":"text","value":")"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"H0"}]},{"type":"text","value":" - Current height of the requesting node (i.e. start height of the jump)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Lo-Height"}]},{"type":"text","value":" and "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Hi-Height"}]},{"type":"text","value":" that the node wants to achieve "},{"type":"element","tag":"u","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"after"}]}]},{"type":"text","value":" the jump"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The sparse block is generated on-the-fly by the target node. It includes all the original kernels (which are, obviously, not a subject to cut-through), as well as inputs and outputs after the following filtration:"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Remove all the inputs and outputs for TXOs that were created above "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"H0"}]},{"type":"text","value":" and spent below or equal "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Lo-Height"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Reduce outputs (i.e. remove the bulletproof) that are spent below or equal "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Hi-Height"}]},{"type":"text","value":" (unless already removed by (1))"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This comes down to the following processing for every input and output"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Inputs\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"if "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"SpendHeight"}]},{"type":"text","value":" > "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Lo-Height"}]},{"type":"text","value":" then include"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"if "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"CreateHeight"}]},{"type":"text","value":" <= "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"H0"}]},{"type":"text","value":" then include"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"if Otherwise - exclude (skip)"}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Outputs\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"if "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"SpendHeight"}]},{"type":"text","value":" > "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Hi-Height"}]},{"type":"text","value":" then include full"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"if "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"SpendHeight"}]},{"type":"text","value":" > "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Lo-Height"}]},{"type":"text","value":" then include reduced"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"if Otherwise - exclude (skip)"}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"pros-and-cons-of-this-scheme"},"children":[{"type":"text","value":"Pros and Cons of this scheme"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The main advantage of the described scheme is its "},{"type":"element","tag":"u","props":{},"children":[{"type":"text","value":"versatility"}]},{"type":"text","value":". Unlike older scheme which supported cut-through only from the genesis, this scheme supports arbitrary height jumps.\nA typical use-case is a node/wallet that was offline for several days/weeks - will be able to download only the minimum info to perform the transition to the most recent state."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Another advantage is that in order to support this the source node doesn't need to \"work hard\", generate a lot of data on-the-fly or prepare in advance (consuming extra storage), which can be exploited by the attacker. With proper data structures generation of sparse blocks can be nearly as fast as retrieving the original blocks."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The price of this versatility is the need to keep the reduced TXOs for reasonably long duration. This is their role. As can be seen, in order to be able to create the sparse block, in particular include all the needed inputs, the target node must keep the information about spent TXOs: their commitment, create and spend heights."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"So that the "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Lo-Horizon"}]},{"type":"text","value":" parameter affects the ability of the node to generate the cut-through data for other nodes. A \"selfish\" node may set "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Lo-Horizon"}]},{"type":"text","value":" equal to "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Hi-Horizon"}]},{"type":"text","value":", means it won't keep reduced TXOs at all. Such a node will only be able to provide cut-through info for others from the genesis. But, as, we said, the reduced TXOs are dramatically smaller than full TXOs, so that keeping them for reasonable duration (months) should not affect the storage size significantly."}]},{"type":"element","tag":"h2","props":{"id":"cut-through-verification"},"children":[{"type":"text","value":"Cut-through verification"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"During the synchronization process for each received blocks there's a verification, that checks as much as possible for the moment, whereas the full verification is postponed until all the sparse blocks are downloaded."}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"For each block:\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Kernels are valid. "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Heightlock"}]},{"type":"text","value":" is in agreement with the block height, Schnorr's signature is valid."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Kernel commitment (MMR root of the kernels of this block) corresponds to the header. This is very important, means all the original transactions are included."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"All inputs reference existing UTXOs in the current state (i.e. TXOs that are unspent yet)."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"All non-reduced outputs have valid bulletproofs."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"All inputs and outputs are interpreted, and the UTXO set undergoes appropriate transformation."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"For each block above or equal "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Lo-Height"}]},{"type":"text","value":" (in addition to the mentioned):\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"UTXO set commitment corresponds to the header.\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"This verification is possible only from "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Lo-Height"}]},{"type":"text","value":" and above, since below this height there may be some TXOs, info about which was totally omitted."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"This verification is not essential to prove the validity of the final state, however it should harden DOS attacks, where the attacker may provide fake inputs and appropriate outputs in later blocks, making this node generate incorrect sparse blocks for others later."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Overall arithmetics. The sum of all outputs minus inputs corresponds to the overall blockchain subsidy for the specified height range."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"In addition, after verifying all individual blocks:\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"u","props":{},"children":[{"type":"text","value":"No reduced UTXOs"}]},{"type":"text","value":". The current UTXO set (unspent TXOs) only contains well-formed TXOs with bulletproofs."}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"possible-dos-attack-and-its-mitigation"},"children":[{"type":"text","value":"Possible DoS attack and its mitigation"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unlike standard synchronization mode, whereas each block is downloaded and fully verified individually, during fast-sync not all such verifications are possible in the middle, hence DoS attacks are theoretically possible. The process however is designed to harden such attacks, while trying to minimize the amount of transferred info in any case."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Many thanks to David Burkett (@DavidBurkett), Grin dev, for discussing such attacks with us."}]},{"type":"element","tag":"h3","props":{"id":"problem-with-lo-horizon"},"children":[{"type":"text","value":"Problem with "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Lo-Horizon"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"As David Burkett pointed-out, the most problematic part of the described scheme is the use of "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Lo-Horizon"}]},{"type":"text","value":". The ever possibility of fully erasing an original TXO from the block means that this block can't be verified on its own, and the attacker can easily modify the in/outs. The node must download all the blocks up to "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Lo-Height"}]},{"type":"text","value":", and only then it's possible to check if this whole block range makes sense. And if it's not - there's no way to find-out which block was incorrect, and where it came from."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"OTOH if "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Lo-Horizon"}]},{"type":"text","value":" is not used, means the Node will have to download all the original commitments, then such an attack becomes infeasible. The attacker can't manipulate the in/outs of the block, because the verifier checks the UTXO set commitment (compares to header) after interpreting every block. It's still possible to craft incorrect blocks (hence full validation at the end is unavoidable), but the attacker would need to craft the appropriate block headers, with valid PoW, which would compete against the honest community."}]},{"type":"element","tag":"h3","props":{"id":"problem-with-hi-horizon"},"children":[{"type":"text","value":"Problem with "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Hi-Horizon"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Another possible attack - inclusion of reduced TXOs (i.e. without the bulletproof) in the block instead of the full ones. That is, making it look like a valid UTXO which would be spent in later blocks, whereas it would not be spent actually. The node can't detect a problem until all the blocks up to "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Hi-Height"}]},{"type":"text","value":" are downloaded. Only after all the blocks were downloaded, the node detects that its UTXO set contains reduced TXOs, which is illegal."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In such a case, however, the node can identify the problematic blocks, the malicious peers, and re-download only the problematic blocks."}]},{"type":"element","tag":"h3","props":{"id":"final-strategy-currently-used"},"children":[{"type":"text","value":"Final strategy currently used"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Minding all the above, the node operates in the following manner"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"During the fast-sync process the node immediately interprets the downloaded blocks and verifies as much as it can to the moment\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Performance impact - verifying many blocks at-once is better than each block individually (related to bulletproof and Schnorr's signature batch verifications).\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"This is compensated by the fact that node still performs a batch verification of many blocks if they all are downloaded from the same peer (then in case of an error they are all considered invalid)."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"Note"}]},{"type":"text","value":": the node during the sync process makes transitions into intermediate states, which can't be fully verified. And since the process may take some time - the node can be \"caught\" in the "},{"type":"element","tag":"u","props":{},"children":[{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"unreliable state"}]}]},{"type":"text","value":".\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Hence during the fast-sync the node doesn't report its tip, and doesn't support generating proofs (for UTXOs, kernels, previous state inclusion and etc.)."}]}]}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"On the first attempt the node tries to sync w.r.t. defined "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Lo-Horizon"}]},{"type":"text","value":". However if the sync attempt fails - the node would retry the sync without it.\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"In the optimistic case the sync should succeed on the first attempt"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"If however it was spoiled by the attacker - it restarts in a more robust mode, at expense of potentially somewhat more data to be downloaded."}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"For such a case there's an option in the protocol to re-download the needed blocks without re-downloading kernels"}]}]}]}]},{"type":"element","tag":"h1","props":{"id":"node-configuration-and-synchronization-logic"},"children":[{"type":"text","value":"Node configuration and synchronization logic"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"As we said, the horizons may be set to arbitrary values (as long as "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Max-rollback-distance"}]},{"type":"text","value":" <= "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Hi-Horizon"}]},{"type":"text","value":" <= "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Lo-Horizon"}]},{"type":"text","value":"). But practically we use only the following configurations:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Archiving node\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Hi-Horizon"}]},{"type":"text","value":" is infinite"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Lo-Horizon"}]},{"type":"text","value":" is infinite"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Always performs a comprehensive synchronization, never deletes history, and can generate any sparse block on request."}]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Standard node\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Hi-Horizon"}]},{"type":"text","value":" = "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Max-rollback-distance"}]},{"type":"text","value":" = 1440"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Lo-Horizon"}]},{"type":"text","value":" = 1440 * 180"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Keeps the most recent history, plus a half-year backlog in terms of reduced TXOs (very modest size). Supports sparse blocks to other standard nodes, unless they were offline for more than half a year."}]}]}]}]},{"type":"element","tag":"h2","props":{"id":"cut-through-mode-activation"},"children":[{"type":"text","value":"Cut-through mode activation"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Cut-through mode is activated automatically when the following criterias are met:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Node is not already in the cut-through mode"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"There is a "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"proven"}]},{"type":"text","value":" state with height which is at least current node height + "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Hi-Horizon"}]},{"type":"text","value":" * 1.5\n"},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"Proven"}]},{"type":"text","value":" means all the headers starting from this one down to the genesis are already downloaded and verified"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Once this happens - node enters the cut-through mode."}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Target-Hi-Height"}]},{"type":"text","value":" is set to "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"ProvenTip.Height"}]},{"type":"text","value":" - "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Hi-Horizon"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Target-Lo-Height"}]},{"type":"text","value":" is set to "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"ProvenTip.Height"}]},{"type":"text","value":" - "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Lo-Horizon"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Note that once selected the "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Target-Lo-Height"}]},{"type":"text","value":" can "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"not"}]},{"type":"text","value":" be changed till the end of the synchronization. The "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"Target-Hi-Height"}]},{"type":"text","value":" however can, and will be increased each time the node will see a higher proven tip."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Once all the sparse blocks are downloaded - they are verified (according to the scheme described above). If the verification passes - the node switches to the standard mode of operation. Otherwise all the downloaded sparse blocks are erased, and the process restarts."}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"max-rollback-distance","depth":2,"text":"Max-rollback distance"},{"id":"hi-horizon","depth":2,"text":"Hi-Horizon"},{"id":"lo-horizon","depth":2,"text":"Lo-Horizon"},{"id":"sparse-blocks","depth":2,"text":"Sparse blocks"},{"id":"pros-and-cons-of-this-scheme","depth":2,"text":"Pros and Cons of this scheme"},{"id":"cut-through-verification","depth":2,"text":"Cut-through verification"},{"id":"possible-dos-attack-and-its-mitigation","depth":2,"text":"Possible DoS attack and its mitigation","children":[{"id":"problem-with-lo-horizon","depth":3,"text":"Problem with Lo-Horizon"},{"id":"problem-with-hi-horizon","depth":3,"text":"Problem with Hi-Horizon"},{"id":"final-strategy-currently-used","depth":3,"text":"Final strategy currently used"}]},{"id":"cut-through-mode-activation","depth":2,"text":"Cut-through mode activation"}]}},"_type":"markdown","_id":"content:docs:core-tech:UTXO-set,-horizons-and-cut-through.md","_source":"content","_file":"docs/core-tech/UTXO-set,-horizons-and-cut-through.md","_extension":"md"}