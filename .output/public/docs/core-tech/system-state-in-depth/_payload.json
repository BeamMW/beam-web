[{"data":1,"prerenderedAt":369},["Reactive",2],{"content-query-1UkgDlypya":3},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":364,"_id":365,"_source":366,"_file":367,"_extension":368},"/docs/core-tech/system-state-in-depth","core-tech",false,"","System State In Depth","So the system state is comprised from the existing UTXOs, Kernels, and inherited system states, each is organized in an appropriate data structure.",{"type":11,"children":12,"toc":358},"root",[13,20,27,32,59,64,89,94,108,132,143,150,167,177,182,200,213,231,243,254,259,265,270,275,281,286,291,296,302,315,320,341],{"type":14,"tag":15,"props":16,"children":17},"element","p",{},[18],{"type":19,"value":9},"text",{"type":14,"tag":21,"props":22,"children":24},"h1",{"id":23},"utxos",[25],{"type":19,"value":26},"UTXOs",{"type":14,"tag":15,"props":28,"children":29},{},[30],{"type":19,"value":31},"The Node must track all the existing unspent UTXOs in the system, and the maturity of each one (i.e. the state height from which it can be spent). In addition we support duplicate UTXOs (there's a use-case for this).",{"type":14,"tag":15,"props":33,"children":34},{},[35,37,43,45,50,52,57],{"type":19,"value":36},"UTXOs are stored in an ",{"type":14,"tag":38,"props":39,"children":40},"code",{"className":7},[41],{"type":19,"value":42},"UtxoTree",{"type":19,"value":44},", which is a variant of our ",{"type":14,"tag":38,"props":46,"children":47},{"className":7},[48],{"type":19,"value":49},"RadixTree",{"type":19,"value":51},". Each UTXO is represented by an ",{"type":14,"tag":38,"props":53,"children":54},{"className":7},[55],{"type":19,"value":56},"UtxoLeaf",{"type":19,"value":58},", which is a leaf node with a key and additional values.",{"type":14,"tag":15,"props":60,"children":61},{},[62],{"type":19,"value":63},"The key is a 321-bit long bits sequence, consisting of (the order matters):",{"type":14,"tag":65,"props":66,"children":67},"ol",{},[68,79],{"type":14,"tag":69,"props":70,"children":71},"li",{},[72,77],{"type":14,"tag":38,"props":73,"children":74},{"className":7},[75],{"type":19,"value":76},"ECC::Point m_Commitment",{"type":19,"value":78}," 257 bits",{"type":14,"tag":69,"props":80,"children":81},{},[82,87],{"type":14,"tag":38,"props":83,"children":84},{"className":7},[85],{"type":19,"value":86},"Height m_Maturity",{"type":19,"value":88}," 64 bits",{"type":14,"tag":15,"props":90,"children":91},{},[92],{"type":19,"value":93},"The value that is stored for each such a node is:",{"type":14,"tag":95,"props":96,"children":97},"ul",{},[98],{"type":14,"tag":69,"props":99,"children":100},{},[101,106],{"type":14,"tag":38,"props":102,"children":103},{"className":7},[104],{"type":19,"value":105},"Input::Count m_Count",{"type":19,"value":107}," 32 bits",{"type":14,"tag":15,"props":109,"children":110},{},[111,113,117,119,123,125,130],{"type":19,"value":112},"So that there is a unique ",{"type":14,"tag":38,"props":114,"children":115},{"className":7},[116],{"type":19,"value":56},{"type":19,"value":118}," for each Commitment + Maturity combination. However if several UTXOs happen to have both those parameters identical - the information is stored within a single ",{"type":14,"tag":38,"props":120,"children":121},{"className":7},[122],{"type":19,"value":56},{"type":19,"value":124}," (with the ",{"type":14,"tag":38,"props":126,"children":127},{"className":7},[128],{"type":19,"value":129},"m_Count",{"type":19,"value":131}," > 1). This is an intentional design decision. To validate transactions it's essential to know the Commitment and the Maturity of the all the UTXOs, whereas other parameters are not important, and such UTXOs are considered identical.",{"type":14,"tag":15,"props":133,"children":134},{},[135,137,141],{"type":19,"value":136},"When an input UTXO is referenced by the Commitment - the Node always looks for the UTXO with the specified Commitment, and the lowest Maturity, which also must not be higher than the current State Height (recall that ",{"type":14,"tag":38,"props":138,"children":139},{"className":7},[140],{"type":19,"value":49},{"type":19,"value":142}," supports search by partially-specified key). So there is no ambiguity with the selection of the input UTXOs.",{"type":14,"tag":144,"props":145,"children":147},"h3",{"id":146},"utxo-hash-proof",[148],{"type":19,"value":149},"UTXO Hash, Proof",{"type":14,"tag":15,"props":151,"children":152},{},[153,155,159,161,165],{"type":19,"value":154},"When the ",{"type":14,"tag":38,"props":156,"children":157},{"className":7},[158],{"type":19,"value":42},{"type":19,"value":160}," hash is evaluated, the ",{"type":14,"tag":38,"props":162,"children":163},{"className":7},[164],{"type":19,"value":56},{"type":19,"value":166}," is hashed by the following formula:",{"type":14,"tag":15,"props":168,"children":169},{},[170,175],{"type":14,"tag":38,"props":171,"children":172},{"className":7},[173],{"type":19,"value":174},"UtxoLeaf.Hash = Hash ( UtxoLeaf.Key | UtxoLeaf.m_Count )",{"type":19,"value":176}," (the 321-bit key is zero-padded to the byte boundary)",{"type":14,"tag":15,"props":178,"children":179},{},[180],{"type":19,"value":181},"The client requests a Merkle proof for an UTXO - the following is specified:",{"type":14,"tag":95,"props":183,"children":184},{},[185,190],{"type":14,"tag":69,"props":186,"children":187},{},[188],{"type":19,"value":189},"Commitment",{"type":14,"tag":69,"props":191,"children":192},{},[193,198],{"type":14,"tag":38,"props":194,"children":195},{"className":7},[196],{"type":19,"value":197},"MaturityMin",{"type":19,"value":199}," - Optionally the minimum Maturity to query (0 by default)",{"type":14,"tag":15,"props":201,"children":202},{},[203,205,211],{"type":19,"value":204},"The Node response includes an ",{"type":14,"tag":206,"props":207,"children":208},"u",{},[209],{"type":19,"value":210},"array",{"type":19,"value":212}," of the following:",{"type":14,"tag":95,"props":214,"children":215},{},[216,221,226],{"type":14,"tag":69,"props":217,"children":218},{},[219],{"type":19,"value":220},"Maturity",{"type":14,"tag":69,"props":222,"children":223},{},[224],{"type":19,"value":225},"Count",{"type":14,"tag":69,"props":227,"children":228},{},[229],{"type":19,"value":230},"Merkle Proof",{"type":14,"tag":15,"props":232,"children":233},{},[234,236,241],{"type":19,"value":235},"After receiving the result the client evaluates the ",{"type":14,"tag":38,"props":237,"children":238},{"className":7},[239],{"type":19,"value":240},"UtxoLeaf.Hash",{"type":19,"value":242}," according to the same formula, substituting the asserted Maturity and Count, and then verifies the Merkle proof.",{"type":14,"tag":15,"props":244,"children":245},{},[246,248,252],{"type":19,"value":247},"Empty array means such an UTXO doesn't exist. The array size is limited to 20 elements, so that if there are more combinations - the client should repeat the query, settings a higher ",{"type":14,"tag":38,"props":249,"children":250},{"className":7},[251],{"type":19,"value":197},{"type":19,"value":253},".",{"type":14,"tag":15,"props":255,"children":256},{},[257],{"type":19,"value":258},"Sounds somewhat complicated, but this is the price of the versatility, supporting duplicates. For regular UTXOs, however, where the duplicates are not possible (unless with a negligible probability), the client won't deal with all this. There will either be a single proof, or no proof.",{"type":14,"tag":21,"props":260,"children":262},{"id":261},"kernels",[263],{"type":19,"value":264},"Kernels",{"type":14,"tag":15,"props":266,"children":267},{},[268],{"type":19,"value":269},"Same idea as with UTXOs, but simpler, because kernels have no Maturity, and duplicates are not supported. So - it's just hashes. The Kernel ID is evaluated, and this is the hash of the leaf node.",{"type":14,"tag":15,"props":271,"children":272},{},[273],{"type":19,"value":274},"For the Kernel proof the client just sends its ID, and gets a single Proof iff the kernel indeed exists in the System state.",{"type":14,"tag":144,"props":276,"children":278},{"id":277},"why-kernel-proofs-are-important",[279],{"type":19,"value":280},"Why Kernel proofs are important?",{"type":14,"tag":15,"props":282,"children":283},{},[284],{"type":19,"value":285},"Unlike UTXOs, Kernels don't contain funds, and can't be used in the future transactions, so why would anyone need a proof for it?",{"type":14,"tag":15,"props":287,"children":288},{},[289],{"type":19,"value":290},"The main reason is that Kernel proof can be used to verify that UTXO is spent. The client may ask for an UTXO proof and get an empty result, but this is not a proof! It's impossible to prove that an object does not exist in the Merkle tree.",{"type":14,"tag":15,"props":292,"children":293},{},[294],{"type":19,"value":295},"So, Kernel proof is the best verification of the transaction, no matter if UTXOs are received or spent.",{"type":14,"tag":21,"props":297,"children":299},{"id":298},"inherited-states",[300],{"type":19,"value":301},"Inherited states",{"type":14,"tag":15,"props":303,"children":304},{},[305,307,313],{"type":19,"value":306},"Implemented in terms of the ",{"type":14,"tag":308,"props":309,"children":310},"strong",{},[311],{"type":19,"value":312},"D-MMR",{"type":19,"value":314}," (Distributed MMR). The leaf nodes are the System State Hashes (not to be confused with the System Definition Hashes). Apart from the somewhat sophisticated D-MMR, the rest is straighforward (generating and verifying proofs).",{"type":14,"tag":15,"props":316,"children":317},{},[318],{"type":19,"value":319},"They are needed in 2 scenarios:",{"type":14,"tag":95,"props":321,"children":322},{},[323,328],{"type":14,"tag":69,"props":324,"children":325},{},[326],{"type":19,"value":327},"Simple scenario: a client was offline for a while, then comes back, and wants to ensure the last State that it observed is still a part of the current consensus branch.",{"type":14,"tag":69,"props":329,"children":330},{},[331,333,339],{"type":19,"value":332},"More complex: Client requests a ",{"type":14,"tag":334,"props":335,"children":336},"em",{},[337],{"type":19,"value":338},"ChainWork Proof",{"type":19,"value":340},", which is a (relatively) compact proof for all the state headers, without fully downloading them all.",{"type":14,"tag":15,"props":342,"children":343},{},[344,349,351,356],{"type":14,"tag":308,"props":345,"children":346},{},[347],{"type":19,"value":348},"Note",{"type":19,"value":350},": In contrast to UTXOs and Kernels, the client knows the structure of the Inherited States tree, hence it receives the proof in a form of a ",{"type":14,"tag":334,"props":352,"children":353},{},[354],{"type":19,"value":355},"Hard",{"type":19,"value":357}," proof, i.e. only the hashes, whereas the hashing direction is deduced automatically.",{"title":7,"searchDepth":359,"depth":359,"links":360},2,[361,363],{"id":146,"depth":362,"text":149},3,{"id":277,"depth":362,"text":280},"markdown","content:docs:core-tech:System-state-in-depth.md","content","docs/core-tech/System-state-in-depth.md","md",1702260907384]