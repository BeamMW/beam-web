[{"data":1,"prerenderedAt":584},["Reactive",2],{"content-query-FiAGZo4Wk6":3},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":579,"_id":580,"_source":581,"_file":582,"_extension":583},"/docs/core-tech/blocks-headers-system-states.-concept-relevant-structures-and-values","core-tech",false,"","Blocks, Headers, System States Concept, Relevant Structures And Values","First let's define terminology.",{"type":11,"children":12,"toc":572},"root",[13,20,50,55,60,67,72,92,97,103,108,232,258,263,296,321,327,332,363,381,399,406,411,447,452,460,465,470,488,493,506,512,517,529,534,540,545,557,562,567],{"type":14,"tag":15,"props":16,"children":17},"element","p",{},[18],{"type":19,"value":9},"text",{"type":14,"tag":21,"props":22,"children":23},"ul",{},[24,38],{"type":14,"tag":25,"props":26,"children":27},"li",{},[28,30,36],{"type":19,"value":29},"System state - is a ",{"type":14,"tag":31,"props":32,"children":33},"em",{},[34],{"type":19,"value":35},"valid",{"type":19,"value":37}," state of the system, which is fully defined by all the existing data (more about this later)",{"type":14,"tag":25,"props":39,"children":40},{},[41,43,48],{"type":19,"value":42},"Block - is an information used to perform a ",{"type":14,"tag":31,"props":44,"children":45},{},[46],{"type":19,"value":47},"transition",{"type":19,"value":49}," from one system state to another.",{"type":14,"tag":15,"props":51,"children":52},{},[53],{"type":19,"value":54},"To avoid ambiguity we refrain from saying \"block hash\" or \"block height\", because, strictly speaking, those are properties of the System state. OTOH blocks are just transactions, which may be combined.",{"type":14,"tag":15,"props":56,"children":57},{},[58],{"type":19,"value":59},"Each state has a header, and there are several structures related to it.",{"type":14,"tag":61,"props":62,"children":64},"h3",{"id":63},"systemstateid",[65],{"type":19,"value":66},"SystemState::ID",{"type":14,"tag":15,"props":68,"children":69},{},[70],{"type":19,"value":71},"Consists of:",{"type":14,"tag":21,"props":73,"children":74},{},[75,84],{"type":14,"tag":25,"props":76,"children":77},{},[78],{"type":14,"tag":79,"props":80,"children":81},"code",{"className":7},[82],{"type":19,"value":83},"Merkle::Hash m_Hash",{"type":14,"tag":25,"props":85,"children":86},{},[87],{"type":14,"tag":79,"props":88,"children":89},{"className":7},[90],{"type":19,"value":91},"Height m_Height",{"type":14,"tag":15,"props":93,"children":94},{},[95],{"type":19,"value":96},"Used to denote an existing known state. (Hash would be enough, but we decided to include the height as well)",{"type":14,"tag":61,"props":98,"children":100},{"id":99},"systemstatefull",[101],{"type":19,"value":102},"SystemState::Full",{"type":14,"tag":15,"props":104,"children":105},{},[106],{"type":19,"value":107},"A full header bound to the system state. Consists of:",{"type":14,"tag":21,"props":109,"children":110},{},[111,140,156,180,196,204],{"type":14,"tag":25,"props":112,"children":113},{},[114,118],{"type":14,"tag":79,"props":115,"children":116},{"className":7},[117],{"type":19,"value":91},{"type":14,"tag":21,"props":119,"children":120},{},[121],{"type":14,"tag":25,"props":122,"children":123},{},[124,126,131,133,138],{"type":19,"value":125},"Our convention: ",{"type":14,"tag":79,"props":127,"children":128},{"className":7},[129],{"type":19,"value":130},"m_Height = 0",{"type":19,"value":132}," - is for initial system state, no data and nothing is interpreted yet. The next state, which is achieved after interpreting the genesis block, has ",{"type":14,"tag":79,"props":134,"children":135},{"className":7},[136],{"type":19,"value":137},"m_Height = 1",{"type":19,"value":139},".",{"type":14,"tag":25,"props":141,"children":142},{},[143,148],{"type":14,"tag":79,"props":144,"children":145},{"className":7},[146],{"type":19,"value":147},"Merkle::Hash m_Prev",{"type":14,"tag":21,"props":149,"children":150},{},[151],{"type":14,"tag":25,"props":152,"children":153},{},[154],{"type":19,"value":155},"explicit reference to prev",{"type":14,"tag":25,"props":157,"children":158},{},[159,164],{"type":14,"tag":79,"props":160,"children":161},{"className":7},[162],{"type":19,"value":163},"Difficulty::Raw m_ChainWork",{"type":14,"tag":21,"props":165,"children":166},{},[167],{"type":14,"tag":25,"props":168,"children":169},{},[170,172,178],{"type":19,"value":171},"Cumulative chainwork (sum of difficulties) ",{"type":14,"tag":173,"props":174,"children":175},"u",{},[176],{"type":19,"value":177},"including",{"type":19,"value":179}," the difficulty of this state.",{"type":14,"tag":25,"props":181,"children":182},{},[183,188],{"type":14,"tag":79,"props":184,"children":185},{"className":7},[186],{"type":19,"value":187},"Merkle::Hash m_Definition",{"type":14,"tag":21,"props":189,"children":190},{},[191],{"type":14,"tag":25,"props":192,"children":193},{},[194],{"type":19,"value":195},"The Hash of the full system definition in this state (more about this later)",{"type":14,"tag":25,"props":197,"children":198},{},[199],{"type":14,"tag":79,"props":200,"children":201},{"className":7},[202],{"type":19,"value":203},"Timestamp m_TimeStamp",{"type":14,"tag":25,"props":205,"children":206},{},[207,212],{"type":14,"tag":79,"props":208,"children":209},{"className":7},[210],{"type":19,"value":211},"PoW m_PoW",{"type":14,"tag":21,"props":213,"children":214},{},[215,220],{"type":14,"tag":25,"props":216,"children":217},{},[218],{"type":19,"value":219},"Proof-of-Work. An equihash solution.",{"type":14,"tag":25,"props":221,"children":222},{},[223,225,230],{"type":19,"value":224},"Contains the ",{"type":14,"tag":79,"props":226,"children":227},{"className":7},[228],{"type":19,"value":229},"Difficulty",{"type":19,"value":231}," of this specific state.",{"type":14,"tag":15,"props":233,"children":234},{},[235,237,242,244,249,251,256],{"type":19,"value":236},"The ",{"type":14,"tag":31,"props":238,"children":239},{},[240],{"type":19,"value":241},"System State Hash",{"type":19,"value":243}," is calculated from all the header parameters, ",{"type":14,"tag":173,"props":245,"children":246},{},[247],{"type":19,"value":248},"including PoW",{"type":19,"value":250},". Not to be confused with ",{"type":14,"tag":79,"props":252,"children":253},{"className":7},[254],{"type":19,"value":255},"m_Definition",{"type":19,"value":257},", it's different.",{"type":14,"tag":15,"props":259,"children":260},{},[261],{"type":19,"value":262},"Note that when many such headers should be presented for consecutive states - there are 3 redundant elements:",{"type":14,"tag":21,"props":264,"children":265},{},[266,276,286],{"type":14,"tag":25,"props":267,"children":268},{},[269,274],{"type":14,"tag":79,"props":270,"children":271},{"className":7},[272],{"type":19,"value":273},"m_Prev",{"type":19,"value":275}," - obviously equals to the Hash of the previous state",{"type":14,"tag":25,"props":277,"children":278},{},[279,284],{"type":14,"tag":79,"props":280,"children":281},{"className":7},[282],{"type":19,"value":283},"m_Height",{"type":19,"value":285}," - just increased by 1",{"type":14,"tag":25,"props":287,"children":288},{},[289,294],{"type":14,"tag":79,"props":290,"children":291},{"className":7},[292],{"type":19,"value":293},"m_ChainWork",{"type":19,"value":295}," - can be calculated from previous header, after adding the difficulty of this one.",{"type":14,"tag":15,"props":297,"children":298},{},[299,301,306,308,313,315,319],{"type":19,"value":300},"So for those cases there are appropriate structures defined: ",{"type":14,"tag":79,"props":302,"children":303},{"className":7},[304],{"type":19,"value":305},"SystemState::Sequence::Prefix",{"type":19,"value":307}," and ",{"type":14,"tag":79,"props":309,"children":310},{"className":7},[311],{"type":19,"value":312},"SystemState::Sequence::Element",{"type":19,"value":314},". And the ",{"type":14,"tag":79,"props":316,"children":317},{"className":7},[318],{"type":19,"value":102},{"type":19,"value":320}," just inherits them both.",{"type":14,"tag":61,"props":322,"children":324},{"id":323},"pow",[325],{"type":19,"value":326},"PoW",{"type":14,"tag":15,"props":328,"children":329},{},[330],{"type":19,"value":331},"BEAM uses equihash mining algorithm. It includes the following:",{"type":14,"tag":21,"props":333,"children":334},{},[335,343,353],{"type":14,"tag":25,"props":336,"children":337},{},[338],{"type":14,"tag":79,"props":339,"children":340},{"className":7},[341],{"type":19,"value":342},"Difficulty m_Difficulty",{"type":14,"tag":25,"props":344,"children":345},{},[346,351],{"type":14,"tag":79,"props":347,"children":348},{"className":7},[349],{"type":19,"value":350},"m_Nonce",{"type":19,"value":352}," - arbitrary 64-bit values",{"type":14,"tag":25,"props":354,"children":355},{},[356,361],{"type":14,"tag":79,"props":357,"children":358},{"className":7},[359],{"type":19,"value":360},"m_Indices",{"type":19,"value":362}," - the solution, array of sorted indexes.",{"type":14,"tag":15,"props":364,"children":365},{},[366,368,372,374,379],{"type":19,"value":367},"The input for the solver/verifier is constructed from all the Header fields, except the PoW solution itself. But it does include the ",{"type":14,"tag":79,"props":369,"children":370},{"className":7},[371],{"type":19,"value":350},{"type":19,"value":373}," and the ",{"type":14,"tag":79,"props":375,"children":376},{"className":7},[377],{"type":19,"value":378},"m_Difficulty",{"type":19,"value":380},". So that the difficulty must be selected before the mining, and can't be adjusted a-posteriori, if the solution eventually could reach higher difficulty (reached a smaller target).",{"type":14,"tag":15,"props":382,"children":383},{},[384,390,392,397],{"type":14,"tag":385,"props":386,"children":387},"strong",{},[388],{"type":19,"value":389},"Note",{"type":19,"value":391},": The whole PoW parameters, including the solution, are accounted for in calculating the System State Hash. This is an intentional design decision, which ensures it's not possible to construct the chain of the system state headers without actually mining them, and then be able to mine only some specific states on-demand. This assumption is essential for ",{"type":14,"tag":31,"props":393,"children":394},{},[395],{"type":19,"value":396},"FlyClient",{"type":19,"value":398}," protocol.",{"type":14,"tag":400,"props":401,"children":403},"h1",{"id":402},"system-definition-hash",[404],{"type":19,"value":405},"System Definition Hash",{"type":14,"tag":15,"props":407,"children":408},{},[409],{"type":19,"value":410},"One of the most important parameters. The complete system state is constructed from the following data:",{"type":14,"tag":21,"props":412,"children":413},{},[414,432,442],{"type":14,"tag":25,"props":415,"children":416},{},[417,419,424,426,431],{"type":19,"value":418},"All the existing non-spent UTXOs, stored with the relevant parameters in an ",{"type":14,"tag":79,"props":420,"children":421},{"className":7},[422],{"type":19,"value":423},"UtxoTree",{"type":19,"value":425},", which is a variant of the ",{"type":14,"tag":79,"props":427,"children":428},{"className":7},[429],{"type":19,"value":430},"RadixTree",{"type":19,"value":139},{"type":14,"tag":25,"props":433,"children":434},{},[435,437,441],{"type":19,"value":436},"All the existing Kernels, stored in the ",{"type":14,"tag":79,"props":438,"children":439},{"className":7},[440],{"type":19,"value":430},{"type":19,"value":139},{"type":14,"tag":25,"props":443,"children":444},{},[445],{"type":19,"value":446},"MMR of all the inherited system states.",{"type":14,"tag":15,"props":448,"children":449},{},[450],{"type":19,"value":451},"The System Definition Hash is defined as:",{"type":14,"tag":15,"props":453,"children":454},{},[455],{"type":14,"tag":79,"props":456,"children":457},{"className":7},[458],{"type":19,"value":459},"System-Definition-Hash = Hash [ InheritedStates.Root | Hash (UTXOs.Root | Kernels.Root) ]",{"type":14,"tag":15,"props":461,"children":462},{},[463],{"type":19,"value":464},"After interpreting the appropriate block, the Full Node evaluates the actual System-Definition-Hash, and compares it with value in the State Header.",{"type":14,"tag":15,"props":466,"children":467},{},[468],{"type":19,"value":469},"Note also that it's actually a root hash of the Merkle tree, whose elements are another Merkle trees. Using this property it's possible to generate and verify Merkle proofs for:",{"type":14,"tag":21,"props":471,"children":472},{},[473,478,483],{"type":14,"tag":25,"props":474,"children":475},{},[476],{"type":19,"value":477},"Existing UTXO in the current system state",{"type":14,"tag":25,"props":479,"children":480},{},[481],{"type":19,"value":482},"Existing Kernel",{"type":14,"tag":25,"props":484,"children":485},{},[486],{"type":19,"value":487},"Inherited System State",{"type":14,"tag":15,"props":489,"children":490},{},[491],{"type":19,"value":492},"All the Verifier needs is the proof, and the System Definition Hash. In addition to verifying the proof, the Verifier ensures the proof suffix is in accordance to the known part of the Merkle tree structure. Means:",{"type":14,"tag":21,"props":494,"children":495},{},[496,501],{"type":14,"tag":25,"props":497,"children":498},{},[499],{"type":19,"value":500},"For UTXOs and Kernels the Verifier knows the hashing direction of the last 2 elements.",{"type":14,"tag":25,"props":502,"children":503},{},[504],{"type":19,"value":505},"For inherited System State the Verifier knows the whole Merkle path, hence all the hashing directions are deduced automatically.",{"type":14,"tag":400,"props":507,"children":509},{"id":508},"history-compression-macroblocks",[510],{"type":19,"value":511},"History compression, Macroblocks",{"type":14,"tag":15,"props":513,"children":514},{},[515],{"type":19,"value":516},"BEAM fully supports the excellent MW feature of history compression with removal of the spent outputs. However unlike what was written in the original MW whitepaper (published by monsieur Tom Elvis Jedusor) - there is no need to provide Merkle proofs or other supplementary info.",{"type":14,"tag":15,"props":518,"children":519},{},[520,522,527],{"type":19,"value":521},"The \"compressed history\" in BEAM is actually just a one huge block, which we call a ",{"type":14,"tag":31,"props":523,"children":524},{},[525],{"type":19,"value":526},"Macroblock",{"type":19,"value":528},", which contains a single huge transaction, which is interpreted (almost) as a regular block/transaction. And this is where the System Definition Hash is of critical importance.",{"type":14,"tag":15,"props":530,"children":531},{},[532],{"type":19,"value":533},"No matter how big the compressed history is, the only thing that matters is the final system state, and it's verified according to the expected System Definition Hash. This is how the authenticity of the compressed history is verified.",{"type":14,"tag":400,"props":535,"children":537},{"id":536},"how-macroblocks-are-generated-and-used-in-beam",[538],{"type":19,"value":539},"How Macroblocks are generated and used in BEAM",{"type":14,"tag":15,"props":541,"children":542},{},[543],{"type":19,"value":544},"There is an implementation of the merging two consequent (macro)blocks. It's a sort of a \"merge sort\" of all the transaction elements (which must be sorted both in input and the resulting blocks), with removal of spent elements. Using this implementation an arbitrary number of blocks may be merged by recursive halving.",{"type":14,"tag":15,"props":546,"children":547},{},[548,550,555],{"type":19,"value":549},"Our initial design was to generate and keep a ",{"type":14,"tag":31,"props":551,"children":552},{},[553],{"type":19,"value":554},"cascade",{"type":19,"value":556}," of macroblocks. Means, the Node each time merges several blocks at the tail, and then they are iteratively merged to the last merged macroblock, only if they are of the same complexity. This means at any moment we have a list of macroblocks of decreasing size, overall O(log(Height)) such blocks.",{"type":14,"tag":15,"props":558,"children":559},{},[560],{"type":19,"value":561},"Then, to import a compressed history, the (other) Node downloads the most recent list of the consecutive macroblocks and interprets them according to their order.",{"type":14,"tag":15,"props":563,"children":564},{},[565],{"type":19,"value":566},"But later we abandoned this idea, mostly because of the hassles for the client to download a list of the macroblocks, especially given the fact they are constantly created and deleted by the generating Node.",{"type":14,"tag":15,"props":568,"children":569},{},[570],{"type":19,"value":571},"So currently the Node just creates a single macroblock once in a while (1 day by default), whereas the cascade-merge is used only internally by the Node to generate each time the new macroblock incrementally.\nWorth to note that during the macroblock generation, which can be a time-consuming operation, the Node is not paralyzed, and works as usual.",{"title":7,"searchDepth":573,"depth":573,"links":574},2,[575,577,578],{"id":63,"depth":576,"text":66},3,{"id":99,"depth":576,"text":102},{"id":323,"depth":576,"text":326},"markdown","content:docs:core-tech:Blocks,-headers,-system-states.-Concept,-relevant-structures-and-values.md","content","docs/core-tech/Blocks,-headers,-system-states.-Concept,-relevant-structures-and-values.md","md",1702260894439]