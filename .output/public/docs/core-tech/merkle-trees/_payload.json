[{"data":1,"prerenderedAt":485},["Reactive",2],{"content-query-hv6b2EZRDj":3},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":480,"_id":481,"_source":482,"_file":483,"_extension":484},"/docs/core-tech/merkle-trees","core-tech",false,"","Merkle Trees","BEAM uses various kinds of Merkle trees and proofs.",{"type":11,"children":12,"toc":471},"root",[13,20,25,40,45,50,57,70,82,87,100,105,116,123,135,147,159,164,175,182,194,199,211,218,223,243,248,253,259,264,269,275,280,285,323,328,333,445,450,456,461,466],{"type":14,"tag":15,"props":16,"children":17},"element","p",{},[18],{"type":19,"value":9},"text",{"type":14,"tag":15,"props":21,"children":22},{},[23],{"type":19,"value":24},"There are 2 kinds of proofs used:",{"type":14,"tag":26,"props":27,"children":28},"ul",{},[29,35],{"type":14,"tag":30,"props":31,"children":32},"li",{},[33],{"type":19,"value":34},"Standard proofs. Consists of an array of hashes, with the flag that specifies the hashing direction (left/right)",{"type":14,"tag":30,"props":36,"children":37},{},[38],{"type":19,"value":39},"Hard proofs. Consists only of hashes. The hashing direction (as long as the proof length) is deduced by the Verifier automatically.",{"type":14,"tag":15,"props":41,"children":42},{},[43],{"type":19,"value":44},"Hard proofs are used where the client is aware of the supposed Merkle tree structure and the position of the needed element. Those proofs are not only a little smaller, but also more robust - they won't allow the Attacker to include different versions of the same element.",{"type":14,"tag":15,"props":46,"children":47},{},[48],{"type":19,"value":49},"In addition there are combinations: a proof which begins as a standard proof, whereas for the suffix the client may deduce the hashing direction. More about this later.",{"type":14,"tag":51,"props":52,"children":54},"h1",{"id":53},"mmr",[55],{"type":19,"value":56},"MMR",{"type":14,"tag":15,"props":58,"children":59},{},[60,62,68],{"type":19,"value":61},"Stands for ",{"type":14,"tag":63,"props":64,"children":65},"em",{},[66],{"type":19,"value":67},"Merkle Mountain Range",{"type":19,"value":69},", which is a fancy term to describe a (potentially) incomplete Merkle tree.",{"type":14,"tag":15,"props":71,"children":72},{},[73,75,80],{"type":19,"value":74},"The underlying objects that are represented by the leaf nodes are converted to hashes according to a specific scheme applicable to the specific object kind (Means - Merkle trees in BEAM never contain ",{"type":14,"tag":63,"props":76,"children":77},{},[78],{"type":19,"value":79},"raw objects",{"type":19,"value":81},", to prevent possible ambiguity attacks).",{"type":14,"tag":15,"props":83,"children":84},{},[85],{"type":19,"value":86},"The hashing used is SHA-256. Non-leaf node hashes are calculated according to",{"type":14,"tag":88,"props":89,"children":90},"blockquote",{},[91],{"type":14,"tag":15,"props":92,"children":93},{},[94],{"type":14,"tag":95,"props":96,"children":97},"code",{"className":7},[98],{"type":19,"value":99},"Hash ( Left-Child | Right->Child )",{"type":14,"tag":15,"props":101,"children":102},{},[103],{"type":19,"value":104},"The tree fill order is left-to-right, whereas at each height two adjacent nodes form a parent node. This forms a sequence of complete trees of decreasing height (a.k.a. Mountain Range). Then adjacent trees are grouped from right to left, and form a mutual parent node, whose children are the roots of those trees. So it's like a regular Merkle tree, except the fact that the root node of the right child is \"promoted\" to the height of the left tree.",{"type":14,"tag":15,"props":106,"children":107},{},[108,114],{"type":14,"tag":109,"props":110,"children":111},"strong",{},[112],{"type":19,"value":113},"Note",{"type":19,"value":115},": in our implementation this promotion doesn't involve any actions, such as hashing with itself (which is used AFAIK in some implementations). This means that the proof length may vary for different elements.",{"type":14,"tag":117,"props":118,"children":120},"h2",{"id":119},"implementation-details",[121],{"type":19,"value":122},"Implementation details",{"type":14,"tag":15,"props":124,"children":125},{},[126,128,133],{"type":19,"value":127},"The core MMR implementation is in ",{"type":14,"tag":95,"props":129,"children":130},{"className":7},[131],{"type":19,"value":132},"Mmr",{"type":19,"value":134}," abstract class. Contains the following virtual functions:",{"type":14,"tag":88,"props":136,"children":137},{},[138],{"type":14,"tag":139,"props":140,"children":142},"pre",{"code":141},"  virtual void LoadElement(Hash&, const Position&) const = 0;\n  virtual void SaveElement(const Hash&, const Position&) = 0;\n",[143],{"type":14,"tag":95,"props":144,"children":145},{"__ignoreMap":7},[146],{"type":19,"value":141},{"type":14,"tag":15,"props":148,"children":149},{},[150,152,157],{"type":19,"value":151},"Whereas ",{"type":14,"tag":95,"props":153,"children":154},{"className":7},[155],{"type":19,"value":156},"Position",{"type":19,"value":158}," is a logical position of an element in the tree (Height and X-coordinate).",{"type":14,"tag":15,"props":160,"children":161},{},[162],{"type":19,"value":163},"Based on the underlying implementation in a derived class, which is supposed to load/save an arbitrary tree element, it supports the expected functionality: appending elements, getting the root hash, getting a proof for a specific element.",{"type":14,"tag":15,"props":165,"children":166},{},[167,169,173],{"type":19,"value":168},"There are various implementation base on ",{"type":14,"tag":95,"props":170,"children":171},{"className":7},[172],{"type":19,"value":132},{"type":19,"value":174},", which differ in how they actually store the hashes.",{"type":14,"tag":176,"props":177,"children":179},"h3",{"id":178},"dmmr-distributed-mmr",[180],{"type":19,"value":181},"DMMR - Distributed MMR",{"type":14,"tag":15,"props":183,"children":184},{},[185,187,192],{"type":19,"value":186},"A more sophisticated variant is called ",{"type":14,"tag":95,"props":188,"children":189},{"className":7},[190],{"type":19,"value":191},"DistributedMmr",{"type":19,"value":193},". It's assumed that the tree data is not stored in one place, but distributed over multiple sites. So that whenever a new element is added to the tree - this element gets a \"reference\" to the existing tree data, and all the new data that should be created (new non-leaf node hashes) is stored in the context of this element only, without the modification of older ones.",{"type":14,"tag":15,"props":195,"children":196},{},[197],{"type":19,"value":198},"This is very useful for branching, whereas one needs to keep track of different variants of what's added to the MMR.",{"type":14,"tag":15,"props":200,"children":201},{},[202],{"type":14,"tag":203,"props":204,"children":208},"a",{"href":205,"rel":206},"https://github.com/beam-mw/beam/wiki/DMMR-internal-layout",[207],"nofollow",[209],{"type":19,"value":210},"More information about their structure is here.",{"type":14,"tag":212,"props":213,"children":215},"h4",{"id":214},"use-case",[216],{"type":19,"value":217},"Use case",{"type":14,"tag":15,"props":219,"children":220},{},[221],{"type":19,"value":222},"Every system state should have an MMR of all the inherited states to support",{"type":14,"tag":26,"props":224,"children":225},{},[226,231],{"type":14,"tag":30,"props":227,"children":228},{},[229],{"type":19,"value":230},"proof of state inclusion in the current state",{"type":14,"tag":30,"props":232,"children":233},{},[234,236,241],{"type":19,"value":235},"Chainwork proof (variation of ",{"type":14,"tag":63,"props":237,"children":238},{},[239],{"type":19,"value":240},"FlyClient",{"type":19,"value":242},").",{"type":14,"tag":15,"props":244,"children":245},{},[246],{"type":19,"value":247},"Every state references the DMMR of the inherited state and adds the extra data to reflect its addition to the tree.",{"type":14,"tag":15,"props":249,"children":250},{},[251],{"type":19,"value":252},"This allows to use the full MMR functionality for every state, no matter if it's the branch tip or not, as well as if it's a part of the current consensus branch or not.",{"type":14,"tag":117,"props":254,"children":256},{"id":255},"multiproof",[257],{"type":19,"value":258},"Multiproof",{"type":14,"tag":15,"props":260,"children":261},{},[262],{"type":19,"value":263},"We use an efficient encoding scheme in a situation where the Prover is supposed to prove multiple elements, whereas the tree structure is known to the Verifier (i.e. the client is able to deduce the Merkle path for any element). In this scenario, during the proof interpretation, both the Prover and the Verifier process hashes up to the point where the Merkle path collides with a path of an element which was included already.",{"type":14,"tag":15,"props":265,"children":266},{},[267],{"type":19,"value":268},"This both saves the proof size and the verification complexity.",{"type":14,"tag":51,"props":270,"children":272},{"id":271},"radix-tree",[273],{"type":19,"value":274},"Radix Tree",{"type":14,"tag":15,"props":276,"children":277},{},[278],{"type":19,"value":279},"(a.k.a. Patricia tree, Merklish (?) tree)",{"type":14,"tag":15,"props":281,"children":282},{},[283],{"type":19,"value":284},"BEAM makes use of special Radix trees, with the following properties:",{"type":14,"tag":26,"props":286,"children":287},{},[288,293,311],{"type":14,"tag":30,"props":289,"children":290},{},[291],{"type":19,"value":292},"It's a variant of a Merkle tree. Means - leaf elements represented by hashes, non-leaf nodes have exactly 2 children, and their hash is evaluated accordingly.",{"type":14,"tag":30,"props":294,"children":295},{},[296,298],{"type":19,"value":297},"It's also a binary search tree, which means:\n",{"type":14,"tag":26,"props":299,"children":300},{},[301,306],{"type":14,"tag":30,"props":302,"children":303},{},[304],{"type":19,"value":305},"logarithmic search, modification",{"type":14,"tag":30,"props":307,"children":308},{},[309],{"type":19,"value":310},"Option to search by either exact or partial key, find elements within key ranges, and etc.",{"type":14,"tag":30,"props":312,"children":313},{},[314,316,321],{"type":19,"value":315},"The internal tree structure is fully defined by the set of contained elements. Regardless to the ",{"type":14,"tag":63,"props":317,"children":318},{},[319],{"type":19,"value":320},"history",{"type":19,"value":322}," (i.e. in which order they were inserted/removed).",{"type":14,"tag":15,"props":324,"children":325},{},[326],{"type":19,"value":327},"The search key is an opaque bits sequence, whereas the length of this sequence must be equal among all the elements contained in the Radix tree. It may, however, be different for different tree instances, which are supposed to contain objects of different kinds (UTXOs, kernels, etc.).",{"type":14,"tag":15,"props":329,"children":330},{},[331],{"type":19,"value":332},"Our Radix trees have the following properties:",{"type":14,"tag":26,"props":334,"children":335},{},[336,354,372,402,420],{"type":14,"tag":30,"props":337,"children":338},{},[339,341],{"type":19,"value":340},"1bit - radix.\n",{"type":14,"tag":26,"props":342,"children":343},{},[344,349],{"type":14,"tag":30,"props":345,"children":346},{},[347],{"type":19,"value":348},"Means - the key bits are evaluated one-by-one, and each bit is potentially a junction.",{"type":14,"tag":30,"props":350,"children":351},{},[352],{"type":19,"value":353},"Non-leaf nodes always have exactly 2 children",{"type":14,"tag":30,"props":355,"children":356},{},[357,359],{"type":19,"value":358},"Lazy split\n",{"type":14,"tag":26,"props":360,"children":361},{},[362,367],{"type":14,"tag":30,"props":363,"children":364},{},[365],{"type":19,"value":366},"Unlike classical radix trees, our trees have non-leaf nodes only where splitting is needed.",{"type":14,"tag":30,"props":368,"children":369},{},[370],{"type":19,"value":371},"In particular if there's only 1 element - there is indeed just a single leaf node.",{"type":14,"tag":30,"props":373,"children":374},{},[375,377],{"type":19,"value":376},"Lazy evaluate\n",{"type":14,"tag":26,"props":378,"children":379},{},[380,392],{"type":14,"tag":30,"props":381,"children":382},{},[383,385,390],{"type":19,"value":384},"Merkle hashes are not immediately recalculated when the tree is modified, instead they're just marked ",{"type":14,"tag":63,"props":386,"children":387},{},[388],{"type":19,"value":389},"dirty",{"type":19,"value":391},".",{"type":14,"tag":30,"props":393,"children":394},{},[395,397,401],{"type":19,"value":396},"They are re-evaluated (recursively) only when needed and only if ",{"type":14,"tag":63,"props":398,"children":399},{},[400],{"type":19,"value":389},{"type":19,"value":391},{"type":14,"tag":30,"props":403,"children":404},{},[405,407],{"type":19,"value":406},"Intrusive-container-like semantics\n",{"type":14,"tag":26,"props":408,"children":409},{},[410,415],{"type":14,"tag":30,"props":411,"children":412},{},[413],{"type":19,"value":414},"To insert an element into the tree it's first allocated with the key (as a single allocation block).",{"type":14,"tag":30,"props":416,"children":417},{},[418],{"type":19,"value":419},"The key of the allocated leaf node is used by the non-leaf nodes (they have a pointer to the same key).",{"type":14,"tag":30,"props":421,"children":422},{},[423,425],{"type":19,"value":424},"No pointer to parent\n",{"type":14,"tag":26,"props":426,"children":427},{},[428,433],{"type":14,"tag":30,"props":429,"children":430},{},[431],{"type":19,"value":432},"To save space pointers to parent are omitted.",{"type":14,"tag":30,"props":434,"children":435},{},[436,438,443],{"type":19,"value":437},"To allow this - during the operation we keep a ",{"type":14,"tag":63,"props":439,"children":440},{},[441],{"type":19,"value":442},"Cursor",{"type":19,"value":444},", which contains the pointers to all the passed nodes to the point.",{"type":14,"tag":15,"props":446,"children":447},{},[448],{"type":19,"value":449},"Speaking technically, non-leaf nodes are allocated/destroyed on-demand, they have the pointer to the key (of one of the leaf nodes contained beneath), and the bit count remaining to the next node. Either the next node is the leaf or not - is determined by the total path length - is it equal to the assumed key length (which is known and supposed to be equal for all the contained elements).",{"type":14,"tag":117,"props":451,"children":453},{"id":452},"merkle-disproof",[454],{"type":19,"value":455},"Merkle disproof",{"type":14,"tag":15,"props":457,"children":458},{},[459],{"type":19,"value":460},"Surprisingly using those radix trees it's possible  to prove (with some assumptions) that there is no queried element.",{"type":14,"tag":15,"props":462,"children":463},{},[464],{"type":19,"value":465},"If there is no queried element - the Prover can present its two closest siblings (or one if it's the maximum/minimum) with their Merkle proofs, which the Verifier can verify indeed belong to adjacent elements.",{"type":14,"tag":15,"props":467,"children":468},{},[469],{"type":19,"value":470},"The Verifier needs, however, to assume that the tree was built according to the rules. In particular when querying for multiple elements, both existing and non-existing, the Verifier should verify that indeed all the presented proofs are in agreement with the assumed element order.",{"title":7,"searchDepth":472,"depth":472,"links":473},2,[474,478,479],{"id":119,"depth":472,"text":122,"children":475},[476],{"id":178,"depth":477,"text":181},3,{"id":255,"depth":472,"text":258},{"id":452,"depth":472,"text":455},"markdown","content:docs:core-tech:Merkle-trees.md","content","docs/core-tech/Merkle-trees.md","md",1702260902673]