[{"data":1,"prerenderedAt":342},["Reactive",2],{"content-query-8NsCkgVmcZ":3},{"_path":4,"_dir":5,"_draft":6,"_partial":6,"_locale":7,"title":8,"description":9,"body":10,"_type":337,"_id":338,"_source":339,"_file":340,"_extension":341},"/docs/core-tech/transaction-graph-obfuscation","core-tech",false,"","Transaction Graph Obfuscation","MW offers great anonymity out-of-the-box, because of the following:",{"type":11,"children":12,"toc":325},"root",[13,20,48,60,67,72,85,97,103,108,120,127,132,145,150,156,161,188,193,200,205,210,216,221,226,278,284,289,294,299,304,309,315,320],{"type":14,"tag":15,"props":16,"children":17},"element","p",{},[18],{"type":19,"value":9},"text",{"type":14,"tag":21,"props":22,"children":23},"ol",{},[24,30,35],{"type":14,"tag":25,"props":26,"children":27},"li",{},[28],{"type":19,"value":29},"No addresses",{"type":14,"tag":25,"props":31,"children":32},{},[33],{"type":19,"value":34},"Transaction values are blinded",{"type":14,"tag":25,"props":36,"children":37},{},[38,40,46],{"type":19,"value":39},"Transaction graph is ",{"type":14,"tag":41,"props":42,"children":43},"u",{},[44],{"type":19,"value":45},"obfuscated",{"type":19,"value":47},".",{"type":14,"tag":15,"props":49,"children":50},{},[51,53,59],{"type":19,"value":52},"Now, it may sound surprising, but the (3) is actually a ",{"type":14,"tag":54,"props":55,"children":56},"strong",{},[57],{"type":19,"value":58},"misconception",{"type":19,"value":47},{"type":14,"tag":61,"props":62,"children":64},"h3",{"id":63},"what-why",[65],{"type":19,"value":66},"What? Why?",{"type":14,"tag":15,"props":68,"children":69},{},[70],{"type":19,"value":71},"As we know, original transactions are merged in a block non-interactively, so that the block is one big transaction, and there is no feasible way to recover the original transaction graph. All the UTXOs look just as arbitrary EC points, and every input can literally correspond to any output. And the bigger the block is - the higher is the obfuscation degree.",{"type":14,"tag":15,"props":73,"children":74},{},[75,77,83],{"type":19,"value":76},"But let's think how the transactions make their way to the block. First they are prepared by the participants, and then they are ",{"type":14,"tag":78,"props":79,"children":80},"em",{},[81],{"type":19,"value":82},"broadcasted",{"type":19,"value":84}," to the network. And the participants are interested to broadcast it to the entire network, to as many nodes as possible, to increase the probability of it being accepted in a block, and the block mined eventually.",{"type":14,"tag":15,"props":86,"children":87},{},[88,90,95],{"type":19,"value":89},"If this is indeed the case, i.e. transactions are just broadcasted as-is to the entire network, then the attacker can easily see the original transaction graph with just a ",{"type":14,"tag":41,"props":91,"children":92},{},[93],{"type":19,"value":94},"single",{"type":19,"value":96}," malicious node, and the later obfuscation in the block doesn't matter anymore.",{"type":14,"tag":61,"props":98,"children":100},{"id":99},"so-what-no-addresses-so-why-bother",[101],{"type":19,"value":102},"So what? No addresses, so why bother?",{"type":14,"tag":15,"props":104,"children":105},{},[106],{"type":19,"value":107},"Is the transaction graph really important? It is. Moreover, in MW hiding the transaction graph seems to be way more important than hiding the user identities.",{"type":14,"tag":15,"props":109,"children":110},{},[111,113,118],{"type":19,"value":112},"MW transaction is anonymous, but it reveals one important thing: there is clearly a ",{"type":14,"tag":41,"props":114,"children":115},{},[116],{"type":19,"value":117},"relation",{"type":19,"value":119}," between the users. So looking at the transaction graph attacker sees the \"relation\" graph. If arbitrary user gets revealed (for whatever reason) - he can disclose the related users, and the attacker knows for sure there is a relation.",{"type":14,"tag":121,"props":122,"children":124},"h4",{"id":123},"example",[125],{"type":19,"value":126},"Example",{"type":14,"tag":15,"props":128,"children":129},{},[130],{"type":19,"value":131},"Suppose Bob has a store, and Alice is his rival, she wants to know Bob's supplier. So she pays Bob (buys something from him), then Bob pays his supplier Charlie, later Charlie pays Dan, Dan pays Erin. Alice sees all those transactions, but has no idea of user identities.",{"type":14,"tag":15,"props":133,"children":134},{},[135,137,143],{"type":19,"value":136},"Eventually Erin gets revealed - buys something from Alice for instance. Alice kindly asks ",{"type":14,"tag":138,"props":139,"children":140},"span",{},[141],{"type":19,"value":142},"bribes / threatens / tortures",{"type":19,"value":144}," Erin to tell her who did he get that UTXO from, this way Dan gets revealed. And so on. At every step Alice is certain there is a relation to the next user.",{"type":14,"tag":15,"props":146,"children":147},{},[148],{"type":19,"value":149},"In contrast, if we assume that the user identity are not well concealed, but the transaction graph is obfuscated - then there is almost no problem. Attacker only gathers the information that a specific user performs a transaction, without any knowledge of the transaction amount, and who is that designated for.",{"type":14,"tag":61,"props":151,"children":153},{"id":152},"are-there-existing-solutions",[154],{"type":19,"value":155},"Are there existing solutions?",{"type":14,"tag":15,"props":157,"children":158},{},[159],{"type":19,"value":160},"Of course. There are known solutions: CoinShuffle, ValueShuffle, but they are not perfect.",{"type":14,"tag":162,"props":163,"children":164},"ul",{},[165,170],{"type":14,"tag":25,"props":166,"children":167},{},[168],{"type":19,"value":169},"This requires groups of unrelated people to cooperate",{"type":14,"tag":25,"props":171,"children":172},{},[173,175],{"type":19,"value":174},"Attacker may create many malicious users \"for free\", that would pretend to participate in CoinShuffle, but in practice can:\n",{"type":14,"tag":162,"props":176,"children":177},{},[178,183],{"type":14,"tag":25,"props":179,"children":180},{},[181],{"type":19,"value":182},"Learn the transaction graph. Would act as unrelated users, but actually belong to the attacker.",{"type":14,"tag":25,"props":184,"children":185},{},[186],{"type":19,"value":187},"DoS attack: created invalid transactions (reference non-existing inputs, etc.)",{"type":14,"tag":15,"props":189,"children":190},{},[191],{"type":19,"value":192},"Those techniques may be useful, but may cause hassles for the users: more preparation time, higher chance to spoil the transaction.\nThis means in turn that the majority of users may decide to skip this obfuscation, and broadcast the original transaction as-is, because \"they have nothing to hide\". This naturally would affect the privacy of other users (anonymity works best when obeyed by all the users).",{"type":14,"tag":194,"props":195,"children":197},"h2",{"id":196},"proposition-in-node-obfuscation",[198],{"type":19,"value":199},"Proposition: In-Node obfuscation",{"type":14,"tag":15,"props":201,"children":202},{},[203],{"type":19,"value":204},"Given the fact that MW transactions are merged non-interactively - Nodes can automatically obfuscate the original transaction graph up to some degree. It may not necessarily replace, but complement transparently the obfuscation done by the users.",{"type":14,"tag":15,"props":206,"children":207},{},[208],{"type":19,"value":209},"This can easily be done in a modified Dandelion. Though originally developed to conceal the user identity, it can be adopted to obfuscate transaction graph during the stem phase, where the transactions get passed through several nodes, but before they are broadcasted to the entire network.",{"type":14,"tag":61,"props":211,"children":213},{"id":212},"non-interactive-merge",[214],{"type":19,"value":215},"Non-interactive merge",{"type":14,"tag":15,"props":217,"children":218},{},[219],{"type":19,"value":220},"That is, while in the stem phase, instead of immediately passing the transaction to a single peer, the Node may wait for some reasonable timeout to try to merge it with another one. So that the transaction grows like a snowball.",{"type":14,"tag":15,"props":222,"children":223},{},[224],{"type":19,"value":225},"The following however should be taken into consideration",{"type":14,"tag":162,"props":227,"children":228},{},[229,234,247,260],{"type":14,"tag":25,"props":230,"children":231},{},[232],{"type":19,"value":233},"To be \"fair\" Node should only merge transactions with comparable fee/size ratio. Otherwise this would reduce the motivation for users to increase the fee (if it'll be diffused anyway).",{"type":14,"tag":25,"props":235,"children":236},{},[237,239],{"type":19,"value":238},"In particular a Node can just  \"hijack\" the fee: append its transaction without any fee to another one.\n",{"type":14,"tag":162,"props":240,"children":241},{},[242],{"type":14,"tag":25,"props":243,"children":244},{},[245],{"type":19,"value":246},"There's nothing can be done to prevent this, but users may see the unfair behavior a-posteriori, and ban that Node.",{"type":14,"tag":25,"props":248,"children":249},{},[250,252],{"type":19,"value":251},"Malicious Node can record the transactions that it passes in the stem phase, and then see the difference when they're broadcasted in the fluff phase.\n",{"type":14,"tag":162,"props":253,"children":254},{},[255],{"type":14,"tag":25,"props":256,"children":257},{},[258],{"type":19,"value":259},"To minimize the amount of leaked info Nodes should merge only transactions of comparable size, instead of incrementally add small transactions.",{"type":14,"tag":25,"props":261,"children":262},{},[263,265],{"type":19,"value":264},"To prevent DoS attacks Nodes should ensure there are no conflicts. Means:\n",{"type":14,"tag":162,"props":266,"children":267},{},[268,273],{"type":14,"tag":25,"props":269,"children":270},{},[271],{"type":19,"value":272},"All the being-merged transactions are valid, and reference existing inputs",{"type":14,"tag":25,"props":274,"children":275},{},[276],{"type":19,"value":277},"No double-spends or etc.",{"type":14,"tag":61,"props":279,"children":281},{"id":280},"dummy-utxos",[282],{"type":19,"value":283},"Dummy UTXOs",{"type":14,"tag":15,"props":285,"children":286},{},[287],{"type":19,"value":288},"Another possibility: any Node can easily \"enlarge\" a transaction by appending one or several dummy outputs to it. By \"dummy\" we mean an UTXO which encodes zero value, but looks just as good as the others.",{"type":14,"tag":15,"props":290,"children":291},{},[292],{"type":19,"value":293},"For every such an appended dummy UTXO the Node sets a random timer (in terms of blocks num), after which it would append the same UTXO as an input in a random transaction later, which (probably) has no relation to the original one.",{"type":14,"tag":15,"props":295,"children":296},{},[297],{"type":19,"value":298},"By this the Node creates a \"background activity\", which is mixed with and should be indistinguishable from the real activity.",{"type":14,"tag":15,"props":300,"children":301},{},[302],{"type":19,"value":303},"The obvious disadvantage of this scheme is the creation of dummy UTXOs, waste of the block space, and network traffic + resources for validating it. But the good part is that it won't affect the scalability in the long-run, since kernels aren't created, and all the dummy UTXOs are spent eventually.",{"type":14,"tag":15,"props":305,"children":306},{},[307],{"type":19,"value":308},"In practice it seems that a combination of both schemes should be used: merge real transactions whenever possible, or add dummies.",{"type":14,"tag":61,"props":310,"children":312},{"id":311},"how-much-should-the-transaction-graph-be-obfuscated",[313],{"type":19,"value":314},"How much should the transaction graph be obfuscated",{"type":14,"tag":15,"props":316,"children":317},{},[318],{"type":19,"value":319},"No exact numbers yet. But it seems that even a slight obfuscation has a dramatic positive effect on the anonymity. For instance, if we merge just 2 transactions at once, it already creates roughly 1/2 uncertainty for the input-output relation. So that if an attacker reveals a user after 10 hops - there is only roughly a 10^-3 probability for the user relation.",{"type":14,"tag":15,"props":321,"children":322},{},[323],{"type":19,"value":324},"Since the transaction being-passed doesn't have an indication is it original or not, the obfuscation criteria should be based on the visible transaction parameters. Which comes down to the number of inputs and outputs.",{"title":7,"searchDepth":326,"depth":326,"links":327},2,[328,330,331,332],{"id":63,"depth":329,"text":66},3,{"id":99,"depth":329,"text":102},{"id":152,"depth":329,"text":155},{"id":196,"depth":326,"text":199,"children":333},[334,335,336],{"id":212,"depth":329,"text":215},{"id":280,"depth":329,"text":283},{"id":311,"depth":329,"text":314},"markdown","content:docs:core-tech:Transaction-graph-obfuscation.md","content","docs/core-tech/Transaction-graph-obfuscation.md","md",1702260908360]